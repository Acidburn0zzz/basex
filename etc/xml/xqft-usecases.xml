<?xml version="1.0" encoding="utf-8"?>
<html lang="EN" xmlns="http://www.w3.org/1999/xhtml" xml:lang="EN">
<head>
<meta name="generator" content=
"HTML Tidy for Windows (vers 14 February 2006), see www.w3.org" />
<title>XQuery and XPath Full Text 1.0 Use Cases</title>

<style type="text/css">
/*<![CDATA[*/
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

div.issue
p.title        { margin-left: -2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

div.issue { border-bottom-color: black;
            border-bottom-style: solid;
            border-bottom-width: 1pt;
            margin-bottom: 20pt;
}

th.issue-toc-head { border-bottom-color: black;
                    border-bottom-style: solid;
                    border-bottom-width: 1pt;
}

      
span.found       { background-color: #FFFFCC; 
                       
                             font-weight: bold; 
                           }
/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href=
"http://www.w3.org/StyleSheets/TR/W3C-WD.css" />
</head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img src=
"http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width=
"72" /></a></p>
<h1><a name="title" id="title"></a>XQuery and XPath Full Text 1.0
Use Cases</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C Working Draft 16
May 2008</h2>
<dl>
<dt>This version:</dt>
<dd><a href=
"http://www.w3.org/TR/2008/WD-xpath-full-text-10-use-cases-20080516/">
http://www.w3.org/TR/2008/WD-xpath-full-text-10-use-cases-20080516/</a></dd>
<dt>Latest version:</dt>
<dd><a href=
"http://www.w3.org/TR/xpath-full-text-10-use-cases/">http://www.w3.org/TR/xpath-full-text-10-use-cases/</a></dd>
<dt>Previous versions:</dt>
<dd><a href=
"http://www.w3.org/TR/2007/WD-xpath-full-text-10-use-cases-20070518/">
http://www.w3.org/TR/2007/WD-xpath-full-text-10-use-cases-20070518/</a>
<a href=
"http://www.w3.org/TR/2006/WD-xmlquery-full-text-use-cases-20060501/">
http://www.w3.org/TR/2006/WD-xmlquery-full-text-use-cases-20060501/</a>
<a href=
"http://www.w3.org/TR/2005/WD-xmlquery-full-text-use-cases-20051103/">
http://www.w3.org/TR/2005/WD-xmlquery-full-text-use-cases-20051103/</a>
<a href=
"http://www.w3.org/TR/2005/WD-xmlquery-full-text-use-cases-20050915/">
http://www.w3.org/TR/2005/WD-xmlquery-full-text-use-cases-20050915/</a>
<a href=
"http://www.w3.org/TR/2005/WD-xmlquery-full-text-use-cases-20050404/">
http://www.w3.org/TR/2005/WD-xmlquery-full-text-use-cases-20050404/</a>
<a href=
"http://www.w3.org/TR/2004/WD-xmlquery-full-text-use-cases-20040709/">
http://www.w3.org/TR/2004/WD-xmlquery-full-text-use-cases-20040709/</a>
<a href=
"http://www.w3.org/TR/2003/WD-xmlquery-full-text-use-cases-20030214/">
http://www.w3.org/TR/2003/WD-xmlquery-full-text-use-cases-20030214/</a></dd>
<dt>Editors:</dt>
<dd>Sihem Amer-Yahia, AT&amp;T Labs - Research</dd>
<dd>Pat Case, Library of Congress</dd>
</dl>
<p>This document is also available in these non-normative formats:
<a href=
"http://www.w3.org/TR/2008/WD-xpath-full-text-10-use-cases-20080516/full-text-use-cases.xml">
XML</a>.</p>
<p class="copyright"><a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&#160;©&#160;2008&#160;<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup>
(<a href="http://www.csail.mit.edu/"><acronym title=
"Massachusetts Institute of Technology">MIT</acronym></a>, <a href=
"http://www.ercim.org/"><acronym title=
"European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
<a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved.
W3C <a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and <a href=
"http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
</div>
<hr />
<div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2>
<p>This document specifies usage scenarios for full-text queries as
part of XML Query <a href="#xquery">[XQuery 1.0: An XML Query
Language]</a> and XPath <a href="#xpath20">[XML Path Language
(XPath) 2.0]</a>.</p>
</div>
<div>
<h2><a name="status" id="status"></a>Status of this Document</h2>
<p><em>This section describes the status of this document at the
time of its publication. Other documents may supersede this
document. A list of current W3C publications and the latest
revision of this technical report can be found in the <a href=
"http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/.</em></p>
<p>This is a <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#maturity-levels">
Working Draft</a> as described in the <a href=
"http://www.w3.org/2004/02/Process-20040205/tr.html">Process
Document</a>. It has been jointly developed by the W3C <a href=
"http://www.w3.org/XML/Query/">XML Query Working Group</a> and the
W3C <a href="http://www.w3.org/Style/XSL/">XSL Working Group</a>,
each of which is part of the <a href=
"http://www.w3.org/XML/Activity">XML Activity</a>. The Working
Groups expect to eventually publish this document as a Working
Group Note.</p>
<p>The WG believes that this document, published on 16 May 2008, is
sufficiently mature and stable that the development community can
begin developing implementation experience and reporting on that
experience.</p>
<p>This document incorporates changes made against the <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#last-call">Last
Call Working Draft</a> of 18 May 2007. Changes to this document
since the <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#last-call">Last
Call Working Draft</a> are detailed in <a href="#ChangeLog"><b>C
Change Log</b></a>.</p>
<p>Please report errors in this document using W3C's <a href=
"http://www.w3.org/Bugs/Public/">public Bugzilla system</a>
(instructions can be found at <a href=
"http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>).
If access to that system is not feasible, you may send your
comments to the W3C XSLT/XPath/XQuery public comments mailing list,
<a href=
"mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>.
It will be very helpful if you include the string “[FTUC]” in the
subject line of your report, whether made in Bugzilla or in email.
Please use multiple Bugzilla entries (or, if necessary, multiple
email messages) if you have more than one comment to make. Archives
of the comments and responses are available at <a href=
"http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>.</p>
<p>Publication as a Working Draft does not imply endorsement by the
W3C Membership. This is a draft document and may be updated,
replaced or obsoleted by other documents at any time. It is
inappropriate to cite this document as other than work in
progress.</p>
<p>This document was produced by groups operating under the
<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5
February 2004 W3C Patent Policy</a>. W3C maintains a <a href=
"http://www.w3.org/2004/01/pp-impl/18797/status#disclosures">public
list of any patent disclosures</a> made in connection with the
deliverables of the XML Query Working Group and also maintains a
<a href=
"http://www.w3.org/2004/01/pp-impl/19552/status#disclosures">public
list of any patent disclosures</a> made in connection with the
deliverables of the XSL Working Group; those pages also include
instructions for disclosing a patent. An individual who has actual
knowledge of a patent which the individual believes contains
<a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">
Essential Claim(s)</a> must disclose the information in accordance
with <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
section 6 of the W3C Patent Policy</a>.</p>
</div>
<div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2>
<p class="toc">1 <a href="#FT_UC_Prelim">Full Text Use Cases:
Preliminaries</a><br />
&#160;&#160;&#160;&#160;1.1 <a href="#FT_UC_Display">Proper Display
of this Unicode Document</a><br />
&#160;&#160;&#160;&#160;1.2 <a href=
"#FT_UC_Intro">Introduction</a><br />
&#160;&#160;&#160;&#160;1.3 <a href=
"#FT_UC_Presentation">Presentation of Use Cases</a><br />
&#160;&#160;&#160;&#160;1.4 <a href="#FT_UC_Schema">Schema for
Sample Data</a><br />
&#160;&#160;&#160;&#160;1.5 <a href="#FT_UC_SampleData">Sample
Data</a><br />
2 <a href="#Element">Use Case "ELEMENT": Queries on XML Elements
with Simple Content</a><br />
&#160;&#160;&#160;&#160;2.1 <a href=
"#element-description">Description</a><br />
&#160;&#160;&#160;&#160;2.2 <a href=
"#element-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.1 <a href=
"#element-queries-results-q1">Q1 Word Query in an Element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.2 <a href=
"#element-queries-results-q2">Q2 Phrase Query in an
Element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3 <a href=
"#element-queries-results-q3">Q3 Phrase Query on Chinese Characters
in an Element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.4 <a href=
"#element-results-q4">Q4 Query in Different Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.5 <a href=
"#element-results-q5">Q5 Query in an Element Returning Different
Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.6 <a href=
"#element-queries-results-q6">Q6 Starts-with Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.7 <a href=
"#element-queries-results-q7">Q7 Entire Element Content
Query</a><br />
3 <a href="#Across">Use Case "ACROSS": Queries Across XML Element
Boundaries</a><br />
&#160;&#160;&#160;&#160;3.1 <a href=
"#across-description">Description</a><br />
&#160;&#160;&#160;&#160;3.2 <a href=
"#across-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1 <a href=
"#across-queries-results-q1">Q1 Query Across Descendant Elements
(No Element Content)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.2 <a href=
"#across-queries-results-q2">Q2 Query Across Descendant Elements
(Highlighting Tags)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.3 <a href=
"#across-queries-results-q3">Q3 Query Across Descendant Elements
(Substantive Tags)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.4 <a href=
"#across-queries-results-q4">Q4 Query Across Siblings</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.5 <a href=
"#across-queries-results-q5">Q5 Query in Different
Sub-Trees</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.6 <a href=
"#across-queries-results-q6">Q6 Query on Entire Document</a><br />
4 <a href="#Other">Use Case "OTHER": Queries on Attribute
Values</a><br />
&#160;&#160;&#160;&#160;4.1 <a href=
"#other-description">Description</a><br />
&#160;&#160;&#160;&#160;4.2 <a href=
"#other-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.1 <a href=
"#other-queries-results-q1">Q1 Query on Attribute</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.2 <a href=
"#other-queries-results-q2">Q2 Query on Element and
Attribute</a><br />
5 <a href="#Wildcard">Use Case "WILDCARD": Character Wildcard
Queries</a><br />
&#160;&#160;&#160;&#160;5.1 <a href=
"#wildcard-description">Description</a><br />
&#160;&#160;&#160;&#160;5.2 <a href=
"#wildcard-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.1 <a href=
"#wildcard-queries-results-q1">Q1 One Character Suffix Wildcard
Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.2 <a href=
"#wildcard-queries-results-q2">Q2 Zero or One Character Prefix
Wildcard Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.3 <a href=
"#wildcard-queries-results-q3">Q3 Zero or More Character Infix
Wildcard Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.4 <a href=
"#wildcard-queries-results-q4">Q4 One or More Character Suffix
Wildcard Query on Part of a Word</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.5 <a href=
"#wildcard-queries-results-q5">Q5 Specified Range of Characters
Suffix Wildcard Query</a><br />
6 <a href="#Stemming">Use Case "STEMMING": Word Stemming
Queries</a><br />
&#160;&#160;&#160;&#160;6.1 <a href=
"#stemming-description">Description</a><br />
&#160;&#160;&#160;&#160;6.2 <a href=
"#stemming-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.2.1 <a href=
"#stemming-queries-results-q1">Q1 Query Stemming on Word
Root</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.2.2 <a href=
"#stemming-queries-results-q2">Q2 Query Stemming on Multiple Word
Roots</a><br />
7 <a href="#Thesaurus">Use Case "THESAURUS": Queries Which Use
Thesauri, Dictionaries, and Taxonomies</a><br />
&#160;&#160;&#160;&#160;7.1 <a href=
"#thesaurus-description">Description</a><br />
&#160;&#160;&#160;&#160;7.2 <a href=
"#thesaurus-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.1 <a href=
"#thesaurus-queries-results-q1">Q1 Query on Synonyms Identified by
a Thesaurus</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.2 <a href=
"#thesaurus-queries-results-q2">Q2 Query on Narrower Terms
Identified by a Thesaurus</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.3 <a href=
"#thesaurus-queries-results-q3">Q3 Query on Broader Terms
Identified by a Thesaurus</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.4 <a href=
"#thesaurus-queries-results-q4">Q4 Query on Word Which Sounds Like
Other Words</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.5 <a href=
"#thesaurus-queries-results-q5">Q5 Query on Word Spelled Similarly
to Other Words</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.6 <a href=
"#thesaurus-queries-results-q6">Q6 Query on Subordinate Terms
Identified by a Taxonomy</a><br />
8 <a href="#Stop-word">Use Case "STOP-WORD": Queries on Stop
Words</a><br />
&#160;&#160;&#160;&#160;8.1 <a href=
"#stop-word-description">Description</a><br />
&#160;&#160;&#160;&#160;8.2 <a href=
"#Stop-word-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.1 <a href=
"#stop-word-queries-results-q1">Q1 Query on Stop Word Treated as a
Stop Word</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.2 <a href=
"#stop-word-queries-results-q2">Q2 Query on Stop Word Not Treated
as a Stop Word</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.3 <a href=
"#stop-word-queries-results-q3">Q3 Query Excluding a Stop Word on a
Stop Word List</a><br />
9 <a href="#Character">Use Case "CHARACTER": Queries Specifying
Normalized Forms of Characters and Tokenized Words</a><br />
&#160;&#160;&#160;&#160;9.1 <a href=
"#character-description">Description</a><br />
&#160;&#160;&#160;&#160;9.2 <a href=
"#character-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;9.2.1 <a href=
"#character-queries-results-q1">Q1 Diacritics Sensitive
Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;9.2.2 <a href=
"#character-queries-results-q2">Q2 Diacritics Insensitive
Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;9.2.3 <a href=
"#character-queries-results-q3">Q3 Query on Word with Upper Case
Characters</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;9.2.4 <a href=
"#character-queries-results-q4">Q4 Query on Word with Upper Case
and Lower Case Characters</a><br />
10 <a href="#Logical">Use Case "LOGICAL": Queries with Logical
Expressions (Or, And, and Not Queries)</a><br />
&#160;&#160;&#160;&#160;10.1 <a href=
"#logical-description">Description</a><br />
&#160;&#160;&#160;&#160;10.2 <a href=
"#logical-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.1 <a href=
"#logical-queries-results-q1">Q1 Or Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.2 <a href=
"#logical-queries-results-q2">Q2 And Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.3 <a href=
"#logical-results-q3">Q3 And Query Ordered</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.4 <a href=
"#logical-queries-results-q4">Q4 Unary Not Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.5 <a href=
"#logical-queries-results-q5">Q5 And Not Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.6 <a href=
"#logical-queries-results-q6">Q6 And Not Query Where Second Operand
Is a Subset of the First Operand</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.7 <a href=
"#logical-queries-results-q7">Q7 Mild Not Query Where Second
Operand Is a Subset of the First Operand</a><br />
11 <a href="#Cardinality">Use Case "CARDINALITY": Queries in Same,
Any, Every Instance of an Element, and Occurrence Count
Query</a><br />
&#160;&#160;&#160;&#160;11.1 <a href=
"#cardinality-description">Description</a><br />
&#160;&#160;&#160;&#160;11.2 <a href=
"#cardinality-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.1 <a href=
"#cardinality-queries-results-q1">Q1 Query in Same Instance of an
Element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.2 <a href=
"#cardinality-queries-results-q2">Q2 Query in Any Instance of an
Element (Existential Quantification)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.3 <a href=
"#cardinality-queries-results-q3">Q3 Query in Every Instance of an
Element (Universal Quantification)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.4 <a href=
"#cardinality-queries-results-q4">Q4 Occurrence Count
Query</a><br />
12 <a href="#Proximity">Use Case "PROXIMITY": Queries on Proximity
Relationships Including Distance, Window, Sentence, and
Paragraph</a><br />
&#160;&#160;&#160;&#160;12.1 <a href=
"#proximity-description">Description</a><br />
&#160;&#160;&#160;&#160;12.2 <a href=
"#proximity-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;12.2.1 <a href=
"#proximity-queries-results-q1">Q1 Unordered Distance
Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;12.2.2 <a href=
"#proximity-queries-results-q2">Q2 Ordered Distance Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;12.2.3 <a href=
"#proximity-queries-results-q3">Q3 Ordered Window Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;12.2.4 <a href=
"#proximity-queries-results-q4">Q4 Unordered Within a Sentence
Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;12.2.5 <a href=
"#proximity-queries-results-q5">Q5 Unordered Within a Paragraph
Query</a><br />
13 <a href="#Axes">Use Case "AXES": Queries Using Relative XPath
Axes</a><br />
&#160;&#160;&#160;&#160;13.1 <a href=
"#axes-description">Description</a><br />
&#160;&#160;&#160;&#160;13.2 <a href=
"#axes-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;13.2.1 <a href=
"#axes-queries-results-q1">Q1 Query on Element and Its
Children</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;13.2.2 <a href=
"#axes-queries-results-q2">Q2 Query on Element Returning Its First
Two Children</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;13.2.3 <a href=
"#axes-queries-results-q3">Q3 Query on Element and Its
Ancestors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;13.2.4 <a href=
"#axes-queries-results-q4">Q4 Query on Element and Its Right
Siblings</a><br />
14 <a href="#Ignore">Use Case "IGNORE": Queries Ignoring Descendant
Element Content</a><br />
&#160;&#160;&#160;&#160;14.1 <a href=
"#ignore-description">Description</a><br />
&#160;&#160;&#160;&#160;14.2 <a href=
"#ignore-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;14.2.1 <a href=
"#ignore-queries-results-q1">Q1 Distance Query Ignoring Content of
All Descendant Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;14.2.2 <a href=
"#ignore-queries-results-q2">Q2 Phrase Query Ignoring Content of
Descendant Element Specified by XPath Expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;14.2.3 <a href=
"#ignore-queries-results-q3">Q3 Phrase Query Ignoring Content of
Descendant Element Specified by Full-Text Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;14.2.4 <a href=
"#ignore-queries-results-q4">Q4 Distance Query Ignoring Content of
Descendant Elements Level by Level</a><br />
15 <a href="#Full-Text-Composability">Use Case
"FULL-TEXT-COMPOSABILITY": Queries Illustrating Composability of
Full-Text with Itself</a><br />
&#160;&#160;&#160;&#160;15.1 <a href=
"#full-text-composability-description">Description</a><br />
&#160;&#160;&#160;&#160;15.2 <a href=
"#full-text-composability-queries-results">Queries and
Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;15.2.1 <a href=
"#full-text-composability-queries-results-q1">Q1 Query on Words and
Phrases in Two Languages</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;15.2.2 <a href=
"#full-text-composability-queries-results-q2">Q2 Phrase and
Distance Query in an Instance of an Element with Stemming</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;15.2.3 <a href=
"#full-text-composability-queries-results-q3">Q3 Nested Distance
Query with Wildcards, Stemming, and Thesaurus Support</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;15.2.4 <a href=
"#full-text-composability-queries-results-q4">Q4 Window Query with
Wildcards and Stemming Ignoring Content of a Descendant
Element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;15.2.5 <a href=
"#full-text-composability-queries-results-q5">Q5 Query on Different
Elements in Different Sub-Trees with Conditional Return</a><br />
16 <a href="#XQuery-XPath-Composability">Use Case
"XQUERY-XPATH-COMPOSABILITY": Queries Illustrating Composability of
Full-Text with Other XQuery and XPath Functionalities</a><br />
&#160;&#160;&#160;&#160;16.1 <a href=
"#xquery-xpath-composability-description">Description</a><br />
&#160;&#160;&#160;&#160;16.2 <a href=
"#xquery-xpath-composability-queries-results">Queries and
Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.1 <a href=
"#xquery-xpath-composability-queries-results-q1">Q1 Full-Text Query
Constructing New Element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.2 <a href=
"#xquery-xpath-composability-queries-results-q2">Q2 Full-Text Query
Returning Count of Descendant Element Occurrences</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.3 <a href=
"#xquery-xpath-composability-queries-results-q3">Q3 Full-Text Query
with Conditional Return</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.4 <a href=
"#xquery-xpath-composability-queries-results-q4">Q4 Full-Text Query
with Numeric Value Comparison</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.5 <a href=
"#xquery-xpath-composability-queries-results-q5">Q5 Full-Text Query
with Character String Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.6 <a href=
"#xquery-xpath-composability-queries-results-q6">Q6 Full-Text Query
with Conditional Return of Boolean Values</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.7 <a href=
"#xquery-xpath-composability-queries-results-q7">Q7 Full-Text Query
with Date Comparison and Element Occurrence Count</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.8 <a href=
"#xquery-xpath-composability-queries-results-q8">Q8 Query with
XPath Expression Within Full-Text Expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.9 <a href=
"#xquery-xpath-composability-queries-results-q9">Q9 Query Using an
XQuery Expression to Determine the Number of Words Allowed in a
Window</a><br />
17 <a href="#Score">Use Case "SCORE": All Queries May Be Written
with Score, Queries in this Section Must Be Written with
Score</a><br />
&#160;&#160;&#160;&#160;17.1 <a href=
"#score-description">Description</a><br />
&#160;&#160;&#160;&#160;17.2 <a href=
"#score-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;17.2.1 <a href=
"#score-queries-results-q1">Q1 Query Returning Scores</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;17.2.2 <a href=
"#score-queries-results-q2">Q2 Query Returning Results with Top
Scores</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;17.2.3 <a href=
"#score-queries-results-q3">Q3 Query Filtering on Scores</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;17.2.4 <a href=
"#score-queries-results-q4">Q4 Query Combining Score and XML
Structure with a Conditional Return</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;17.2.5 <a href=
"#score-queries-results-q5">Q5 Query Returning All Books Ordered by
Score</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;17.2.6 <a href=
"#score-queries-results-q6">Q6 Query with Weight
Declaration</a><br /></p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3>
<p class="toc">A <a href=
"#Acknowledgements">Acknowledgements</a><br />
B <a href="#References">References</a><br />
&#160;&#160;&#160;&#160;B.1 <a href="#primary">References
(Primary)</a><br />
&#160;&#160;&#160;&#160;B.2 <a href="#background">References
(Background)</a><br />
C <a href="#ChangeLog">Change Log</a><br /></p>
</div>
<hr />
<div class="body">
<div class="div1">
<h2><a name="FT_UC_Prelim" id="FT_UC_Prelim"></a>1 Full Text Use
Cases: Preliminaries</h2>
<div class="div2">
<h3><a name="FT_UC_Display" id="FT_UC_Display"></a>1.1 Proper
Display of this Unicode Document</h3>
<p>(1) Use a current operating system and browser.</p>
<p>(2) If necessary, set the character encoding in the browser
manually to Unicode or UTF-8. Often this setting may be changed
from the View menu.</p>
<p>(3) If after setting the character encoding to Unicode, the
Chinese characters in the subject elements of the sample data still
do not display, it is likely that the browser cannot locate a font
that contains Chinese characters in Unicode encoding. It might be
necessary to add a Unicode font, preferably Arial Unicode MS.</p>
</div>
<div class="div2">
<h3><a name="FT_UC_Intro" id="FT_UC_Intro"></a>1.2
Introduction</h3>
<p>The use cases listed below were created by the <a href=
"http://www.w3.org/XML/Query/">XML Query Working Group</a> and the
<a href="http://www.w3.org/Style/XSL/">XSL Working Group</a> to
illustrate important applications of full-text querying within an
XML query language. Each use case exercises a specific
functionality relevant to full-text querying. An XML Schema and
sample input data are provided. Each use case specifies a query
applied to the input data, a solution in XQuery, a solution in
XPath (when possible), and the expected results.</p>
<p>The document supplements the XML Query Use Cases which can be
found in the W3C XML Query Use Cases <a href=
"#xquery-use-cases">[XML Query Use Cases]</a>. Use cases for
character string querying are included in the XML Query Use Cases,
not in this document.</p>
<p>These use cases:</p>
<p>(1) Present some possible functions and features for tokenized
text support in XQuery and XPath.</p>
<p>(2) Illustrate simple and complex queries. The more complex
queries would normally only be constructed by programmers,
librarians, and other expert users. Sometimes they may be provided
for novice users via saved queries and graphical user interfaces.
Each query illustrates a single functionality. Queries may overlap
in their functionalities (e.g., phrases and ordered distance
queries allowing no intervening words). Overlapping and similar
functionalities are noted in the comments on query behavior.</p>
<p>(3) Draw from sample data which are almost entirely in English.
Use cases in other languages are solicited, especially where they
illustrate language-specific implementations of functions and
features. Among the most sought after are use cases for queries
using prefix and infix wild cards, proximity queries, and operators
and queries requiring functionality which may not have Western
language equivalents.</p>
<p>(4) Include queries which in most instances can be written with
pure Boolean full-text predicates or with scoring (e.g., scoring on
the number of occurrences of a word or phrase, scoring on how close
words are to one another within a distance query, scoring on how
similar a word is to the one being stemmed) <a href=
"#BYR99">[BYR99]</a> <a href="#HTK00">[HTK00]</a>. A few, those in
Section 17 (SCORE), cannot be written with Boolean full-text
predicates. Scoring methodologies will not be defined in this
recommendation. Scoring will be implementation-defined. Results are
provided in document order, except those in Section 17 (SCORE).
Results could be returned ordered differently, such as by relevance
(based on implementation-defined scoring) or explicitly by
element.</p>
<p>(5) Query element content. See Section 4 (OTHER) for explicit
queries on attribute values.</p>
<p>(6) Include queries which are case-insensitive. When returning a
paragraph, the text is returned as it occurs in the data model.
This approach was chosen to keep the sample data short and the
expected results meaningful. It would have been equally valid to
return only the character queried. A case-sensitive query is found
in Section 9 (CHARACTER).</p>
<p>(7) Include queries which when they target XML elements are
understood, unless otherwise stated, to query text within any text
node descendant of the element.</p>
<p>(8) Include queries which return only elements and attributes
which meet all the conditions specified in the query. In
particular, pure Boolean full-text predicate queries return results
where the Boolean conditions in the query are satisfied, i.e., are
used to select what is being returned to users.</p>
<p>Query results may be returned in different ways. From a query
for books containing the word "usability", users might be
interested in returning, for each book containing the word
"usability", its number and its entire content. In another
situation for the same query, users might be interested in
returning, for each book containing the word "usability", its
number and only the elements and attributes in the content which
contain the word "usability". As in this second situation, the
queries in these use cases return only elements and attributes
which meet all the conditions specified in the query.</p>
<p>The Return clause may also include additional or different
elements and attributes if specified, and may construct new
elements.</p>
<p>(9) Include queries which provide some of the basic
functionality of fuzzy match querying (e.g., wildcards, stemming,
thesaurus support, proximity).</p>
<p>(10) Provide highlighting of found words and phrases in the
expected results of queries as an aid to users. The presence of
highlighting says nothing about whether highlighting will be a
feature of XQuery or XPath full-text querying.</p>
<p>(11) Display query solutions in XQuery and when possible in
XPath. Queries that may not be written in XPath include those that
contain element constructors and that cannot be written without let
and order by clauses.</p>
<p>Examples of full-text querying functionalities for XML query
languages can be found in <a href="#FGR01">[FGR01]</a>, <a href=
"#HTK00">[HTK00]</a>, <a href="#MJK98">[MJK98]</a>, <a href=
"#SCH01">[SCH01]</a> and <a href="#TWE00">[TWE00]</a>.</p>
<p>To make the output more readable, the output of queries has been
formatted using white space which may not be returned by a query
processor. This white space should not be considered normative for
the correctness of results.</p>
</div>
<div class="div2">
<h3><a name="FT_UC_Presentation" id="FT_UC_Presentation"></a>1.3
Presentation of Use Cases</h3>
<p>The queries in these use cases are presented in the following
format:</p>
<p>Query number &#160;&#160;Query title</p>
<p>User statement of query</p>
<p>Statement of functionality illustrated by query</p>
<ul>
<li>
<p>Operands: Parts of words, words, phrases</p>
</li>
<li>
<p>Functionality: Operators, functions, collations, other
functionality</p>
</li>
<li>
<p>Data context: One XPath expression locating the data being
queried.</p>
</li>
<li>
<p>Query context: One or more XPath expressions locating the
elements and attributes to be queried. The context of elements and
attributes used in the Query context is relative to the Data
context defined above.</p>
</li>
<li>
<p>Return: One or more XPath expressions which are returned only if
the conditions specified in the query are met. Returned elements or
attributes may differ from those specified in the Query context.
Newly constructed elements might be returned. As in the Query
context, the context of elements and attributes in Return
statements is relative to the Data context defined above.</p>
</li>
<li>
<p>Comments: Comments on query behavior in general, and against the
sample data in particular, plus the rationale for including this
query in the use cases.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
Solutions illustrating XQuery Full Text syntax  
appear here. All queries may be written in XQuery.

Solutions are written with pure Boolean full-text predicates 
and not to invoke scoring, except for those in Section 17 (SCORE), 
however all the queries in the document may be written as scored 
queries with the addition of a score variable.

All queries are written assuming the default function namespace, 
without the fn: prefix.
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
Solutions illustrating XPath Full Text syntax appear 
(when the query may be written in XPath) here.

Solutions are written with pure Boolean full-text predicates 
and not to invoke scoring, except for those in Section 17 (SCORE), 
however most of the queries in the document may be written as 
scored queries with the addition of a score variable.

All queries are written assuming the default function namespace, 
without the fn: prefix.
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
Results are provided here.
                                
Found words and phrases are <span class=
"found">highlighted</span>. 
                                
For brevity, only the elements and attributes which meet 
the conditions specified in the query are displayed. Others are
replaced with ...s.

Results are provided in document order, except those 
in Section 17 (SCORE)
</pre></div>
</div>
<div class="div2">
<h3><a name="FT_UC_Schema" id="FT_UC_Schema"></a>1.4 Schema for
Sample Data</h3>
<p>The example queries in these use cases are based on a collection
with the following XML Schema:</p>
<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" 
version="1.0"&gt;
&lt;xs:import namespace="http://www.w3.org/XML/1998/namespace" 
schemaLocation = "http://www.w3.org/2001/xml.xsd"/&gt;
   &lt;xs:element name="books"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;A possible XML Schema for Sample Data 
         in XQuery and XPath Full Text Use Cases
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexType&gt;
         &lt;xs:sequence maxOccurs="unbounded"&gt;
            &lt;xs:element name="book"&gt;
               &lt;xs:complexType&gt;
                  &lt;xs:sequence&gt;
                     &lt;xs:element name="metadata" 
                     type="metadataType"/&gt;
                     &lt;xs:element name="content" 
                     type="contentType"/&gt;
                  &lt;/xs:sequence&gt;
                  &lt;xs:attribute name="number" type="xs:integer"/&gt;
               &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;
   &lt;/xs:element&gt;
   &lt;xs:complexType name="anyXMLTextType" mixed="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;free text, contains any well-formed 
         XML&lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:sequence&gt;
         &lt;xs:any processContents="skip" minOccurs="0" 
         maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="metadataType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="title"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="shortTitle" 
                     type="xs:string"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
         &lt;xs:element name="author" type="xs:string" 
         minOccurs="0" 
         maxOccurs="unbounded"/&gt;
         &lt;xs:element name="publicationInfo" 
         type="publicationInfoType"/&gt;
         &lt;xs:element name="price" minOccurs="0"&gt;
            &lt;xs:simpleType&gt;
               &lt;xs:restriction base="xs:float"&gt;
                  &lt;xs:minInclusive value="0"/&gt;
                  &lt;xs:maxInclusive value="10000"/&gt;
               &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
         &lt;/xs:element&gt;
         &lt;xs:element name="subjects" 
         maxOccurs="unbounded"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="subject" type="xs:string" 
               maxOccurs="unbounded"/&gt;
            &lt;/xs:sequence&gt;
               &lt;xs:attribute ref="xml:lang"/&gt;
         &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="publicationInfoType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="place" type="xs:string" 
         minOccurs="0"/&gt;
         &lt;xs:element name="publisher" type="xs:string" 
         maxOccurs="unbounded"/&gt;
         &lt;xs:element name="dateIssued" type="xs:string"/&gt;
         &lt;xs:element name="dateRevised" type="xs:string"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="contentType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="introduction" 
         type="introductionType" 
         minOccurs="0"/&gt;
         &lt;xs:element name="part" type="partType" 
         maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="introductionType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="author" type="xs:string" 
         minOccurs="0"/&gt;
         &lt;xs:element name="p" maxOccurs="unbounded"&gt;
            &lt;xs:complexType mixed="true"&gt;
               &lt;xs:choice minOccurs="0" 
               maxOccurs="unbounded"&gt;
                  &lt;xs:element name="b"/&gt;
                  &lt;xs:element name="emph"/&gt;
                  &lt;xs:element name="i"/&gt;
               &lt;/xs:choice&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="partType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="container" type="xs:string" 
         minOccurs="0"&gt;
             &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="type" type="xs:string"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
         &lt;xs:element name="title" type="titleType" 
         minOccurs="0"/&gt;
         &lt;xs:element name="introduction" 
         type="introductionType" 
         minOccurs="0"/&gt;
         &lt;xs:element name="chapter" type="chapterType" 
         minOccurs="0" maxOccurs="unbounded"/&gt;
         &lt;xs:element name="component" 
         type="componentType" 
         minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="number" type="xs:string"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="chapterType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="title" type="xs:string"/&gt;
         &lt;xs:element name="p" type="anyXMLTextType" 
         maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="footnoteType" mixed="true"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="citation" type="xs:string"
         minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="url" type="xs:anyURI"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="componentType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="container" type="xs:string" 
         minOccurs="0"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="type" type="xs:string"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
         &lt;xs:element name="componentTitle" 
         type="componentTitleType"/&gt;
         &lt;xs:element name="subComponent" 
         type="subComponentType" 
         minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="titleType" mixed="true"&gt;
      &lt;xs:all minOccurs="0"&gt;
         &lt;xs:element name="date" type="xs:string"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="normalize" 
                     type="xs:string"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
      &lt;/xs:all&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="componentTitleType" 
   mixed="true"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="componentDate" 
         type="xs:string" 
        minOccurs="0"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="normalize" 
                     type="xs:string"
                      use="optional"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt; 
         &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="subComponentType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="container" type="xs:string" 
         minOccurs="0"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="type" type="xs:string"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt; 
        &lt;/xs:element&gt;
        &lt;xs:element type="componentTitleType"/&gt;
        &lt;xs:element name="subsubComponent" 
        type="subSubComponentType" 
        minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="subSubComponentType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="container" type="xs:string" 
         minOccurs="0"&gt;
           &lt;xs:complexType&gt;
              &lt;xs:simpleContent&gt;
                 &lt;xs:extension base="xs:string"&gt;
                    &lt;xs:attribute name="type" type="xs:string"/&gt;
                 &lt;/xs:extension&gt;
              &lt;/xs:simpleContent&gt;
           &lt;/xs:complexType&gt; 
        &lt;/xs:element&gt;
        &lt;xs:element name="componentTitle" 
        type="componentTitleType"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;
</pre></div>
</div>
<div class="div2">
<h3><a name="FT_UC_SampleData" id="FT_UC_SampleData"></a>1.5 Sample
Data</h3>
<p>The data consists of a collection of three books. Two are
primarily instructive text. The third is a guide to a manuscript
collection. All contain metadata and full text.</p>
<p>The sample data binds to this URL:
"http://bstore1.example.com/full-text.html".</p>
<div class="exampleInner">
<pre>
&lt;books&gt;
&lt;book number="1"&gt;
   &lt;metadata&gt;
      &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
      the Usability of a Web Site Through Expert Reviews and 
      Usability Testing&lt;/title&gt;
      &lt;author&gt;Millicent Marigold&lt;/author&gt;
      &lt;author&gt;Montana Marigold&lt;/author&gt;
      &lt;publicationInfo&gt;
         &lt;place&gt;New York&lt;/place&gt;
         &lt;publisher&gt;Ersatz Publications&lt;/publisher&gt;
         &lt;dateIssued&gt;2001&lt;/dateIssued&gt;
         &lt;dateRevised&gt;2002&lt;/dateRevised&gt;
      &lt;/publicationInfo&gt;
      &lt;price&gt;25.99&lt;/price&gt;   
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;Usability testing&lt;/subject&gt;
         &lt;subject&gt;Web site development&lt;/subject&gt;        
         &lt;subject&gt;Heuristic evaluation&lt;/subject&gt;
         &lt;subject&gt;Cognitive walk-through&lt;/subject&gt;
         &lt;subject&gt;Web site usability&lt;/subject&gt;
      &lt;/subjects&gt;
      &lt;subjects xml:lang="fr"&gt;        
         &lt;subject&gt;Tests d'ergonomie&lt;/subject&gt;
         &lt;subject&gt;Développement de site web&lt;/subject&gt;        
         &lt;subject&gt;Évaluation heuristique&lt;/subject&gt;
         &lt;subject&gt;Parcours cognitif&lt;/subject&gt;
         &lt;subject&gt;Ergonomie de site web&lt;/subject&gt;     
      &lt;/subjects&gt;
      &lt;subjects xml:lang="zh"&gt;    
         &lt;subject&gt;可用性测试&lt;/subject&gt;
         &lt;subject&gt;网站建置&lt;/subject&gt;        
         &lt;subject&gt;启发式评价&lt;/subject&gt;
         &lt;subject&gt;认知推演&lt;/subject&gt;
         &lt;subject&gt;网站可用性&lt;/subject&gt;
      &lt;/subjects&gt;
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;author&gt;Elina Rose&lt;/author&gt;
         &lt;p&gt;The usability of a Web site is how well the 
         site supports the user in achieving specified 
         goals. A Web site should facilitate learning, 
         and enable efficient and effective task 
         completion, while propagating few errors. 
         Satisfaction with the site is also important. 
         The user must not only be well-served, but must 
         feel well-served.&lt;/p&gt; 
         &lt;p&gt;Expert reviews and usability testing are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them away from your site.&lt;/p&gt;
         &lt;p&gt;The most successful projects employ multiple 
         methods in multiple iterations. As Millicent 
         Marigold remarked during a recent conference, 
         "Don't stop. Iterate, iterate, then iterate 
         again."&lt;/p&gt;
         &lt;p&gt;This book has been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Expert reviewers identify problems 
            and recommend changes to web sites based 
            on research in human computer interaction 
            and their experience in the field.&lt;/p&gt; 
            &lt;p&gt;Two expert review methods are discussed 
            here. They are heuristic evaluation and 
            cognitive walk-through.&lt;/p&gt; 
            &lt;p&gt;Expert review methods should be 
            initiated early in the development process, 
            as soon as paper &lt;b&gt;p&lt;/b&gt;rototypes 
            (hand-drawn pictures of Web pages) or 
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are 
            available. They should be conducted using 
            the hardware and software similar to that 
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
         &lt;chapter&gt;
            &lt;title&gt;Heuristic Evaluation&lt;/title&gt;
            &lt;p&gt;Expert reviewers critique an interface to 
            determine conformance with recognized 
            usability principles. &lt;footnote&gt;One of the 
            best known lists of heuristics is &lt;citation 
            url="http://www.useit.com/papers/heuristic
            /heuristic_list.html"&gt;Ten Usability 
            Heuristics by Jacob Nielson&lt;/citation&gt;. Another 
            is &lt;citation url="http://usability.gov
            /guidelines/index.html"&gt; Research-Based Web 
            Design and Usability Guidelines&lt;/citation&gt;
            &lt;/footnote&gt;&lt;/p&gt; 
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Cognitive Walk-Through&lt;/title&gt;
            &lt;p&gt;Expert reviewers evaluate Web site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "Would a 
            user know by looking at the screen how to 
            complete the first step of the task?" and "If 
            the user completed the first step, would the 
            user know what to do next?," with the goal of 
            identifying any obstacles to completing the 
            task and assessing whether the user would 
            cognitively be aware that he was successful in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Usability Testing&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some tests of the site with your unique 
            audience or audiences by conducting usability 
            testing.&lt;/p&gt;
            &lt;p&gt;Users are asked to complete tasks which 
            measure the success of the information 
            architecture and navigational elements of the 
            site.&lt;/p&gt;
            &lt;p&gt;Then changes are made to improve service to 
            users.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;metadata&gt;
      &lt;title shortTitle="Usability Basics"&gt;Usability 
      Basics: How to Plan for and Conduct Usability Tests 
      on Web Site Thereby Improving the Usability of Your 
      Web Site&lt;/title&gt;
      &lt;publicationInfo&gt;
         &lt;place&gt;New York&lt;/place&gt;
         &lt;publisher&gt;Ersatz Publications&lt;/publisher&gt;
         &lt;publisher&gt;Electronic BookWorks&lt;/publisher&gt;         
         &lt;dateIssued&gt;2000&lt;/dateIssued&gt;
         &lt;dateRevised&gt;2001&lt;/dateRevised&gt;
      &lt;/publicationInfo&gt;
      &lt;price&gt;174.00&lt;/price&gt;   
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;Usability testing&lt;/subject&gt;
         &lt;subject&gt;Web site development&lt;/subject&gt;
         &lt;subject&gt;Guides and finding aids&lt;/subject&gt;
      &lt;/subjects&gt;
      &lt;subjects xml:lang="fr"&gt;
         &lt;subject&gt;Tests d'ergonomie&lt;/subject&gt;
         &lt;subject&gt;Développement de site web&lt;/subject&gt;
         &lt;subject&gt;Guides et outils de recherche&lt;/subject&gt;
      &lt;/subjects&gt;
      &lt;subjects xml:lang="zh"&gt;
         &lt;subject&gt;可用性测试&lt;/subject&gt;
         &lt;subject&gt;网站建置&lt;/subject&gt;
         &lt;subject&gt;指南和检索工具&lt;/subject&gt;
      &lt;/subjects&gt;
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability tests on Web sites. Usability 
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         &lt;p&gt;This book has not been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting Usability 
            Tests&lt;/title&gt; 
            &lt;p&gt;Take the following steps to plan usability 
            testing. &lt;step number="1"&gt;Clarify and 
            articulate the goal of the usability testing.
            &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
            are critical for users to be able to complete 
            successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
            a script of questions or instructions which 
            will prompt the user to attempt those 
            tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
            users and begin recruiting them.&lt;/step&gt; &lt;step 
            number="5"&gt;Conduct a pretest on a few users.
            &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
            on insights gleaned from the pretest.&lt;/step&gt; 
            &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability Tests&lt;/title&gt; 
         &lt;p&gt;Users can be tested at any computer 
            workstation &lt;footnote&gt;They may be more 
            comfortable at their own workstation than in 
            a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;Usability 
            testing can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no guidance or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in Web site components which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of testing and changes, until 
            users are successful in the accomplishing the 
            tasks.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;metadata&gt;
      &lt;title shortTitle="Usabilityguy Manuscript 
      Guide"&gt;John Wesley Usabilityguy: A Register of His 
      Papers&lt;/title&gt;
      &lt;author&gt;Millicent Marigold&lt;/author&gt;
      &lt;author&gt;Morty Marigold&lt;/author&gt;
      &lt;publicationInfo&gt;  
         &lt;place&gt;Washington, D.C.&lt;/place&gt;    
         &lt;publisher&gt;Ersatz Manuscript Library&lt;/publisher&gt;
         &lt;dateIssued&gt;1998&lt;/dateIssued&gt;
         &lt;dateRevised&gt;2002&lt;/dateRevised&gt;
      &lt;/publicationInfo&gt;
      &lt;price&gt;21.49&lt;/price&gt;   
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;Computers&lt;/subject&gt;
         &lt;subject&gt;Software evaluation&lt;/subject&gt;
         &lt;subject&gt;Usability testing&lt;/subject&gt;
         &lt;subject&gt;Manuscript collections&lt;/subject&gt;
      &lt;/subjects&gt;
      &lt;subjects xml:lang="fr"&gt;
         &lt;subject&gt;Ordinateurs&lt;/subject&gt;
         &lt;subject&gt;Évaluation de logiciels&lt;/subject&gt;
         &lt;subject&gt;Tests d'ergonomie&lt;/subject&gt;
         &lt;subject&gt;Collections de manuscrits&lt;/subject&gt;
      &lt;/subjects&gt;
      &lt;subjects xml:lang="zh"&gt;
         &lt;subject&gt;计算机&lt;/subject&gt;
         &lt;subject&gt;软件评价&lt;/subject&gt;
         &lt;subject&gt;可用性测试&lt;/subject&gt;
         &lt;subject&gt;手稿专藏&lt;/subject&gt;
      &lt;/subjects&gt;
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of software 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Correspondence, telegrams, memoranda, journals, 
            logs, testimony, approved travel orders, invitations, 
            charts, graphs, forms, biographical data, photographs, 
            book drafts, clippings and other printed matter, 
            résumés and miscellaneous material. Organized by 
            name of person or organization, topic, or type of 
            material.&lt;/p&gt;
         &lt;/introduction&gt;
         &lt;component&gt;&lt;container type="box"&gt;1&lt;/container&gt;
           &lt;componentTitle&gt;Computers&lt;/componentTitle&gt;
           &lt;subComponent&gt;
              &lt;componentTitle&gt;Software, 
              &lt;componentDate normalize="1946/1947"&gt;1946-1947
              &lt;/componentDate&gt;
              &lt;/componentTitle&gt;
           &lt;/subComponent&gt;
           &lt;subComponent&gt;
              &lt;componentTitle&gt;Human Computer Interaction 
              research, &lt;componentDate normalize="1945/1952"&gt;
              1945-1952&lt;/componentDate&gt;
              &lt;/componentTitle&gt;
              &lt;subsubComponent&gt;
                 &lt;componentTitle&gt;Flow diagram, 
                 &lt;componentDate normalize="1950"&gt;1950
                 &lt;/componentDate&gt;
                 &lt;/componentTitle&gt;
              &lt;/subsubComponent&gt;
              &lt;subsubComponent&gt;
                 &lt;componentTitle&gt;General, 
                 &lt;componentDate normalize="1947/1951"&gt;1947-1951
                 &lt;/componentDate&gt;
                 &lt;/componentTitle&gt;
              &lt;/subsubComponent&gt;
              &lt;subsubComponent&gt;&lt;container type="box"&gt;2&lt;/container&gt;
                 &lt;componentTitle&gt;Eye Movement research,
                 &lt;componentDate normalize="1949/1950"&gt;1949-1950
                 &lt;/componentDate&gt;
                 &lt;/componentTitle&gt;
              &lt;/subsubComponent&gt; 
              &lt;subsubComponent&gt;
                 &lt;componentTitle&gt;User profiling, 
                 &lt;componentDate normalize="1950/1959"&gt;1950s
                 &lt;/componentDate&gt;
                 &lt;/componentTitle&gt;
              &lt;/subsubComponent&gt;
            &lt;/subComponent&gt;
         &lt;/component&gt;
         &lt;component&gt;
           &lt;componentTitle&gt;Web User Appreciation Award, 
           &lt;componentDate normalize="1956"&gt;1956&lt;/componentDate&gt;
           &lt;/componentTitle&gt;
         &lt;/component&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Correspondence, articles, book drafts, notes, 
            contracts, clippings, and printed matter. Arranged 
            alphabetically by type (articles, books, reports, 
            and miscellaneous) and therein alphabetically by 
            type of material, subject, or title.&lt;/p&gt;
         &lt;/introduction&gt;
         &lt;component&gt;
            &lt;componentTitle&gt;Writings by Usabilityguy
            &lt;/componentTitle&gt;
            &lt;subComponent&gt;
               &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
               1996&lt;/componentDate&gt;
               &lt;/componentTitle&gt; 
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How Many Users Are Enough 
                  for User Testing?"&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How to Evaluate Results from 
                  User Tests."&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt;
               &lt;subsubComponent&gt;
                  &lt;container type="box"&gt;5&lt;/container&gt;
                  &lt;componentTitle&gt;"When Are You Done Testing?"
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt;
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"Do-It-Yourself User Testing"
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
            &lt;/subComponent&gt;
         &lt;/component&gt;
         &lt;component&gt;
            &lt;componentTitle&gt;Charitable Contributions
            &lt;/componentTitle&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Diseases: AIDS, Hepatitis, 
               Tuberculosis &lt;componentDate normalize=
               "1990/1999"&gt;1990-1999&lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Environmental Conservation: 
               Rivers &lt;componentDate normalize="1995"&gt;1995
               &lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt;
         &lt;/component&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;
&lt;/books&gt;
</pre></div>
</div>
</div>
<div class="div1">
<h2><a name="Element" id="Element"></a>2 Use Case "ELEMENT":
Queries on XML Elements with Simple Content</h2>
<div class="div2">
<h3><a name="element-description" id="element-description"></a>2.1
Description</h3>
<p>These use cases query words and phrases in XML elements with
simple content.</p>
<p>These use cases begin with the simplest queries possible. They
query a word or phrase in an element with simple content and no
descendants. One of these queries is on Chinese characters. Some
queries return additional or different elements than were queried.
A query queries and returns the full document. Others find a phrase
only when it starts an element and find a exact phrase when it is
the entire content of an element, allowing full-text variations,
such as case, diacritics, and wildcards.</p>
</div>
<div class="div2">
<h3><a name="element-queries-results" id=
"element-queries-results"></a>2.2 Queries and Results</h3>
<div class="div3">
<h4><a name="element-queries-results-q1" id=
"element-queries-results-q1"></a>2.2.1 Q1 Word Query in an
Element</h4>
<p>Find all book titles containing the word "usability".</p>
<p>This query finds a word in an element.</p>
<ul>
<li>
<p>Operands: "usability"</p>
</li>
<li>
<p>Functionality: word query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title</p>
</li>
<li>
<p>Return: ./metadata/title</p>
</li>
<li>
<p>Comments: This is the simplest query possible, a query on a word
in an element. This query does not employ wildcards, stemming, or
thesaurus support. While this query finds useful results in the
sample data, many queries such as one on the word "test" would not.
A query on the word "test" would return no results, missing the
word variants which exist in the sample data: "pretest", "tested",
"testers", "testimony", "testing", and "tests".</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
   /books/book/metadata/title[. ftcontains "usability"]
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book/metadata/title[. ftcontains "usability"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
and <span class="found">Usability</span> Testing&lt;/title&gt;

&lt;title shortTitle="Usability Basics"&gt;<span class=
"found">Usability</span> 
Basics: How to Plan for and Conduct <span class=
"found">Usability</span> Tests 
on Web Site Thereby Improving the <span class=
"found">Usability</span> of Your 
Web Site&lt;/title&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="element-queries-results-q2" id=
"element-queries-results-q2"></a>2.2.2 Q2 Phrase Query in an
Element</h4>
<p>Find all book subjects containing the phrase "usability
testing".</p>
<p>This query finds a phrase in an element.</p>
<ul>
<li>
<p>Operands: "usability testing"</p>
</li>
<li>
<p>Functionality: phrase query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/subjects/subject</p>
</li>
<li>
<p>Return: ./metadata/subjects/subject</p>
</li>
<li>
<p>Comments: This is a simple query on a phrase in an element. Like
an ordered distance query allowing no intervening words, the words
in this phrase query must be adjacent to each other and must appear
in the order specified. While this query finds useful results in
the sample data, many queries such as one on "software developer"
would not. A query on the phrase "software developer" would return
no results, missing "developer of software" which exists in the
sample data.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
   /books/book/metadata/subjects/subject[. ftcontains 
   "usability testing"]
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book/metadata/subjects/subject[. ftcontains 
"usability testing"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;subject&gt;<span class=
"found">Usability testing</span>&lt;/subject&gt;
                                                
&lt;subject&gt;<span class=
"found">Usability testing</span>&lt;/subject&gt;

&lt;subject&gt;<span class=
"found">Usability testing</span>&lt;/subject&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="element-queries-results-q3" id=
"element-queries-results-q3"></a>2.2.3 Q3 Phrase Query on Chinese
Characters in an Element</h4>
<p>Find all book subjects containing the phrase (n-gram) "网站".</p>
<p>This query finds a phrase (n-gram) in an element.</p>
<ul>
<li>
<p>Operands: "网站"</p>
</li>
<li>
<p>Functionality: phrase query, language qualifier</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/subjects/subject</p>
</li>
<li>
<p>Return: ./metadata/subjects/subject</p>
</li>
<li>
<p>Comments: This query finds a phrase (n-gram) consisting of two
Chinese characters. It assumes a specific language dependent
tokenization.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
   /books/book/metadata/subjects/subject[. ftcontains 
   "网站" language "zh"]
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book/metadata/subjects/subject[. ftcontains 
"网站" language "zh"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;subject&gt;<span class="found">网站</span>建置&lt;/subject&gt;  
                                            
&lt;subject&gt;<span class="found">网站</span>可用性&lt;/subject&gt;

&lt;subject&gt;<span class="found">网站</span>建置&lt;/subject&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="element-results-q4" id="element-results-q4"></a>2.2.4
Q4 Query in Different Elements</h4>
<p>Find all books with "usability tests" in book or chapter
titles.</p>
<p>This query finds a phrase in different elements.</p>
<ul>
<li>
<p>Operands: "usability tests"</p>
</li>
<li>
<p>Functionality: phrase query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title,
./content/part/chapter/title</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query is an example of a query in two different
elements.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $title := $book/metadata/title[. ftcontains "usability tests"] 
   union $book/content/part/chapter/title[. ftcontains "usability 
   tests"] 
where count($title) &gt; 0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(./metadata/title[. ftcontains "usability tests"] 
union ./content/part/chapter/title[. ftcontains "usability tests"])&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
      &lt;title shortTitle="Usability Basics"&gt;Usability 
      Basics: How to Plan for and Conduct <span class=
"found">Usability Tests</span> 
      on Web Site Thereby Improving the Usability of 
      Your Web Site&lt;/title&gt; 
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting <span class=
"found">Usability</span>
            <span class="found">Tests</span>&lt;/title&gt; 
            ...
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting <span class=
"found">Usability Tests</span>&lt;/title&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt;
      .... 
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="element-results-q5" id="element-results-q5"></a>2.2.5
Q5 Query in an Element Returning Different Elements</h4>
<p>Find all books with the phrase "usability testing" in some
subject.</p>
<p>This query finds a phrase in an element and returns different
elements from the same document.</p>
<ul>
<li>
<p>Operands: "usability testing"</p>
</li>
<li>
<p>Functionality: phrase query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/subjects/subject</p>
</li>
<li>
<p>Return: ./metadata/title, ./metadata/author</p>
</li>
<li>
<p>Comments: This query queries the <code>subject</code> element,
but does not return it. It returns two different elements.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
where $book//subject ftcontains "usability testing"
return $book/metadata/(title|author)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[./metadata/subjects/subject 
ftcontains "usability testing"]/metadata/(title|author)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
the Usability of a Web Site Through Expert Reviews 
and Usability Testing&lt;/title&gt; 
&lt;author&gt;Millicent Marigold&lt;/author&gt;     
&lt;author&gt;Montana Marigold&lt;/author&gt; 
   
&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;
   
&lt;title shortTitle="Usabilityguy Manuscript 
Guide"&gt;John Wesley Usabilityguy: A Register of His 
Papers&lt;/title&gt;
&lt;author&gt;Millicent Marigold&lt;/author&gt;
&lt;author&gt;Morty Marigold&lt;/author&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="element-queries-results-q6" id=
"element-queries-results-q6"></a>2.2.6 Q6 Starts-with Query</h4>
<p>Find all book titles which start with "improving" followed
within 2 words by "usability".</p>
<p>This query finds an element which starts with specific
words.</p>
<ul>
<li>
<p>Operands: "improving" "usability"</p>
</li>
<li>
<p>Functionality: word queries, ordered distance (0 to 2
intervening words), starts-with functionality</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title</p>
</li>
<li>
<p>Return: ./metadata/title</p>
</li>
<li>
<p>Comments: The starts-with functionality restricts the query to
the first words or phrase in an element. It is especially useful in
querying journal titles (e.g., <em>Journal of Psychology</em>) in
large library collections. This query does not find Book 2 which
contains the phrase "improving the usability" in the
<code>title</code> element, because the <code>title</code> element
does not start with "improving" followed within 2 words by
"usability".</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $title := $book/metadata/title[. ftcontains 
"improving" ftand "usability" ordered  
distance at most 2 words at start]
where count($title)&gt;0
return $title
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book/metadata/title[count(. ftcontains 
"improving" ftand "usability" ordered 
distance at most 2 words  at start)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Improving Web Site Usability"&gt;<span class=
"found">Improving 
the Usability</span> of a Web Site Through Expert Reviews and 
Usability Testing&lt;/title&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="element-queries-results-q7" id=
"element-queries-results-q7"></a>2.2.7 Q7 Entire Element Content
Query</h4>
<p>Find all books with the entire title "improve the usability of a
web site through expert reviews and usability testing", allowing
any form of the word "improve".</p>
<p>This query finds the phrase when it is the entire content of an
element.</p>
<ul>
<li>
<p>Operands: "improve the usability of a web site through expert
reviews and usability testing"</p>
</li>
<li>
<p>Functionality: phrase query, character wildcard (suffix) (0 or
more), entire element content functionality</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title</p>
</li>
<li>
<p>Return: ./metadata/title</p>
</li>
<li>
<p>Comments: This query insists that the element contains the
entire phrase being queried, no more and no less. It allows
full-text variations, such as case, diacritics, and wildcards.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $exactTitle := $book/metadata/title[. ftcontains 
   "improv.* the usability of a web site through expert 
   reviews and usability testing" entire content]
where count($exactTitle)&gt;0
return $exactTitle
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book/metadata/title[count(. ftcontains 
"improv.* the usability of a web site through expert 
reviews and usability testing" entire content)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Improving Web Site Usability"&gt;<span class=
"found">Improving 
the Usability of a Web Site Through Expert Reviews and 
Usability Testing</span>&lt;/title&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Across" id="Across"></a>3 Use Case "ACROSS": Queries
Across XML Element Boundaries</h2>
<div class="div2">
<h3><a name="across-description" id="across-description"></a>3.1
Description</h3>
<p>These use cases by default query across XML element
boundaries.</p>
<p>Boundaries include XML tags: Start-Tags, End-Tags, and
Empty-Element Tags. Descendant XML tags and attribute values are
removed from the string to be queried by tokenization before the
query. At the XQuery Data Model level tags are a syntactic
element.</p>
<p>Find queries in an element which do not query some or all of its
descendant elements in Section 14 (IGNORE).</p>
</div>
<div class="div2">
<h3><a name="across-queries-results" id=
"across-queries-results"></a>3.2 Queries and Results</h3>
<div class="div3">
<h4><a name="across-queries-results-q1" id=
"across-queries-results-q1"></a>3.2.1 Q1 Query Across Descendant
Elements (No Element Content)</h4>
<p>Find all book chapters containing the phrase "one of the best
known lists of heuristics is Ten Usability Heuristics".</p>
<p>This query crosses element boundaries.</p>
<ul>
<li>
<p>Operands: "one of the best known lists of heuristics is Ten
Usability Heuristics"</p>
</li>
<li>
<p>Functionality: phrase query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/part/chapter</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: Querying across element boundaries is similar to an
XQuery and XPath character string function converting the sub-tree
under an element into a string by removing all markup. The
<code>citation</code> element tags, including element name and
attribute values, have been removed by tokenization.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $chap := $book//chapter[. ftcontains 
   "one of the best known lists of heuristics is 
   Ten Usability Heuristics"]
where count($chap) &gt; 0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//chapter ftcontains "one of 
the best known lists of heuristics is Ten Usability 
Heuristics")&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         ...
         &lt;chapter&gt; 
            &lt;title&gt;Heuristic Evaluation&lt;/title&gt; 
            &lt;p&gt;Expert reviewers critique an interface to
            determine conformance with recognized 
            usability principles. &lt;footnote&gt;<span class=
"found">One of the</span>
            <span class=
"found">best known lists of heuristics is</span> &lt;citation
            url="http://www.useit.com/papers/heuristic
            /heuristic_list.html"&gt; <span class=
"found">Ten Usability</span> 
            <span class=
"found">Heuristics</span> by Jacob Nielson&lt;/citation&gt;. Another
            is &lt;citation url="http://usability.gov
            /guidelines/index.html"&gt; Research-Based Web
            Design and Usability Guidelines&lt;/citation&gt;
            &lt;/footnote&gt;&lt;/p&gt; 
         &lt;/chapter&gt;
         ...
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="across-queries-results-q2" id=
"across-queries-results-q2"></a>3.2.2 Q2 Query Across Descendant
Elements (Highlighting Tags)</h4>
<p>Find all part introductions containing the word
"prototypes".</p>
<p>This query crosses element boundaries.</p>
<ul>
<li>
<p>Operands: "prototypes"</p>
</li>
<li>
<p>Functionality: word query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/part/introduction</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: Querying across element boundaries is similar to an
XQuery and XPath character string function converting the sub-tree
under an element into a string by removing all markup. The
<code>bold</code> element tags, including element name, have been
removed by tokenization.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $intro := $book/content/part/introduction[. ftcontains 
   "prototypes"]
where count($intro)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(./content/part/introduction ftcontains 
"prototypes")&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt; 
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;introduction&gt;
            &lt;p&gt;Expert review methods should be
            initiated early in the development process, 
            as soon as paper &lt;b&gt;<span class=
"found">p</span>&lt;/b&gt;<span class="found">rototypes</span>
            (hand-drawn pictures of Web pages) or
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are
            available. They should be conducted using
            the hardware and software similar to that 
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
         ...
      &lt;/part&gt;
      ...
   &lt;/content&gt;  
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="across-queries-results-q3" id=
"across-queries-results-q3"></a>3.2.3 Q3 Query Across Descendant
Elements (Substantive Tags)</h4>
<p>Find all book text with the word "tests".</p>
<p>This query finds a word in an element and its descendants.</p>
<ul>
<li>
<p>Operands: "tests"</p>
</li>
<li>
<p>Functionality: word query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: Querying across element boundaries is similar to an
XQuery and XPath character string function converting the sub-tree
under an element into a string by removing all markup. Element
tags, including element name and attribute values, have been
removed by tokenization, including <code>part</code>,
<code>chapter</code>, <code>title</code>, <code>p</code>,
<code>component</code>, and <code>componentTitle</code> tags.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content[. ftcontains "tests"]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(./content ftcontains "tests")&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Usability Testing&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some <span class=
"found">tests</span> of the site with your unique 
            audience or audiences by conducting usability 
            testing.&lt;/p&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
      ...
   &lt;/content&gt;
&lt;/book&gt;      
   
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability <span class=
"found">tests</span> on Web sites. Usability 
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
          ...
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting Usability 
            <span class="found">Tests</span>&lt;/title&gt;   
            ...
         &lt;/chapter&gt;
      &lt;/part&gt;   
      ...
   &lt;/content&gt;
&lt;/book&gt;   

&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;     
   &lt;content&gt;
      ...
      &lt;component&gt;
         &lt;componentTitle&gt;Writings by Usabilityguy
         &lt;/componentTitle&gt;
         &lt;subComponent&gt;
           &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
           1996&lt;/componentDate&gt;
           &lt;/componentTitle&gt; 
           ...
           &lt;subsubComponent&gt;
           &lt;componentTitle&gt;"How to Evaluate Results from 
           User <span class=
"found">Tests</span>."&lt;/componentTitle&gt;
           &lt;/subsubComponent&gt;
         &lt;/subComponent&gt;
         ...
      &lt;component&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="across-queries-results-q4" id=
"across-queries-results-q4"></a>3.2.4 Q4 Query Across Siblings</h4>
<p>Find all book text with the phrase "usability testing once the
problems".</p>
<p>This query finds a phrase which begins in one element and ends
in a sibling.</p>
<ul>
<li>
<p>Operands: "usability testing once the problems"</p>
</li>
<li>
<p>Functionality: phrase query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: Querying across element boundaries is similar to an
XQuery and XPath character string function converting the sub-tree
under an element into a string by removing all markup. Element
tags, including element name and attribute values, have been
removed by tokenization, including <code>title</code> and
<code>p</code> tags.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains 
   "usability testing once the problems"]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains "usability 
testing once the problems")&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;<span class=
"found">Usability Testing</span>&lt;/title&gt;
            &lt;p&gt;<span class=
"found">Once the problems</span> identified by expert 
            reviews have been corrected, it is time to 
            conduct some tests of the site with your unique 
            audience or audiences by conducting usability 
            testing.&lt;/p&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="across-queries-results-q5" id=
"across-queries-results-q5"></a>3.2.5 Q5 Query in Different
Sub-Trees</h4>
<p>Find all books with word "identify" in book introductions or
part introductions.</p>
<p>This query finds a word in an element in different
sub-trees.</p>
<ul>
<li>
<p>Operands: "identify"</p>
</li>
<li>
<p>Functionality: word query, character wildcard (suffix) (0 or
more)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/introduction,
./content/part/introduction</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query looks for a word in multiple instances of
the <code>introduction</code> element which appear as children of
the <code>content</code> or <code>part</code> elements.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $bi := $book/content/introduction[./p ftcontains 
   "identif.*" with wildcards]
let $pi := $book/content/part/introduction[./p ftcontains 
   "identif.*" with wildcards]
where count($bi)&gt;0 and count($pi)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(./content/introduction ftcontains 
"identif.*" with wildcards and ./content/part/introduction 
ftcontains "identif.*" with wildcards)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;  
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;                                          
      &lt;introduction&gt;
         ...
         &lt;p&gt;Expert reviews and usability testing are 
         methods of <span class=
"found">identifying</span> problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them away from your site.&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;    
         &lt;introduction&gt;
             &lt;p&gt;Expert reviewers <span class=
"found">identify</span> problems 
             and recommend changes to web sites based 
             on research in human computer interaction 
             and their experience in the field.&lt;/p&gt; 
             ...
         &lt;/introduction&gt;
         ...
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt; 
</pre></div>
</div>
<div class="div3">
<h4><a name="across-queries-results-q6" id=
"across-queries-results-q6"></a>3.2.6 Q6 Query on Entire
Document</h4>
<p>Find all books if any one contains the word "mouse".</p>
<p>This query finds a word in a document (anywhere in the
document), crossing all element boundaries</p>
<ul>
<li>
<p>Operands: "mouse"</p>
</li>
<li>
<p>Functionality: word query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: It queries the root element and all its descendants.
Querying across element boundaries is similar to an XQuery and
XPath character string function converting the sub-tree under an
element into a string by removing all markup. Element tags,
including element name and attribute values, have been removed by
tokenization. This query looks for a word inside an entire document
and returns the entire document if the word exists. It does not
employ wildcards, stemming, or thesaurus support. It is similar to
search engine queries that search a collection of documents and
return a subset of the searched collection.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
where $book ftcontains "mouse"
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[. ftcontains "mouse"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability Tests&lt;/title&gt; 
            ...
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;Usability 
            testing can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no guidance or comments to the user. <span class=
"found">Mouse</span> 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         ...
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Other" id="Other"></a>4 Use Case "OTHER": Queries on
Attribute Values</h2>
<div class="div2">
<h3><a name="other-description" id="other-description"></a>4.1
Description</h3>
<p>Unlike all the other use cases in this document which query
element content implicitly, these use cases query XML attribute
values. Attribute values are not queried implicitly; they are
queried explicitly.</p>
</div>
<div class="div2">
<h3><a name="other-queries-results" id=
"other-queries-results"></a>4.2 Queries and Results</h3>
<div class="div3">
<h4><a name="other-queries-results-q1" id=
"other-queries-results-q1"></a>4.2.1 Q1 Query on Attribute</h4>
<p>Find all books with "improve" "web" "usability" in the short
title.</p>
<p>This query finds multiple words in an attribute allowing word
variants and allowing the words in any order with up to a specified
number of intervening words.</p>
<ul>
<li>
<p>Operands: "improve" "web" "usability"</p>
</li>
<li>
<p>Functionality: word queries, stemming, unordered distance (0 to
2 intervening words)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title/@shortTitle</p>
</li>
<li>
<p>Return: ./metadata/title</p>
</li>
<li>
<p>Comments: This query illustrates full-text querying in an
attribute.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
where $book/metadata/title/@shortTitle ftcontains "improve" 
   ftand "web" ftand "usability" with stemming distance at most 2 words    
return $book/metadata/title
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(./metadata/title/@shortTitle ftcontains 
"improve" ftand "web" ftand "usability" with stemming  
distance at most 2 words)&gt;0]/metadata/title
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="<span class=
"found">Improving</span> <span class="found">Web</span> 
Site <span class=
"found">Usability</span>"&gt;Improving the Usability of a 
Web Site Through Expert Reviews and Usability Testing&lt;/title&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="other-queries-results-q2" id=
"other-queries-results-q2"></a>4.2.2 Q2 Query on Element and
Attribute</h4>
<p>Find all books with the phrase "manuscript guides" in the short
title and the phrase "user profiling" in a component title.</p>
<p>This query finds a phrase in an attribute and a phrase in an
element.</p>
<ul>
<li>
<p>Operands: "manuscript guides" "user profiling"</p>
</li>
<li>
<p>Functionality: phrase queries, stemming, <code>and</code>
query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title/@shortTitle,
./componentTitle</p>
</li>
<li>
<p>Return: ./metadata/title/@shortTitle/text()</p>
</li>
<li>
<p>Comments: This query combines querying in an element with
querying in an attribute.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $stitle := $book/metadata/title[./@shortTitle ftcontains 
   "manuscript guides" with stemming]
let $cont := $book//componentTitle[. ftcontains 
   "user profiling" with stemming]
where count($stitle)&gt;0 and count($cont)&gt;0
return data($book/metadata/title/@shortTitle)
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
Usabilityguy <span class="found">Manuscript Guide</span>
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Wildcard" id="Wildcard"></a>5 Use Case "WILDCARD":
Character Wildcard Queries</h2>
<div class="div2">
<h3><a name="wildcard-description" id=
"wildcard-description"></a>5.1 Description</h3>
<p>These use cases illustrate queries which use wildcards to append
or insert a character or sequence of characters to a word or a part
of a word. Character wildcards may be prefix (appended before the
first character), infix (inserted into a word), or suffix (appended
after the last character).</p>
</div>
<div class="div2">
<h3><a name="wildcard-queries-results" id=
"wildcard-queries-results"></a>5.2 Queries and Results</h3>
<div class="div3">
<h4><a name="wildcard-queries-results-q1" id=
"wildcard-queries-results-q1"></a>5.2.1 Q1 One Character Suffix
Wildcard Query</h4>
<p>Find all books with the word "test" with a one character suffix
in the text.</p>
<p>This query finds a word with a one character suffix (one
character after the last character).</p>
<ul>
<li>
<p>Operands: "test"</p>
</li>
<li>
<p>Functionality: word query, character wildcard (suffix) (1)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query finds "tests", but not "pretest, "tested",
"testers", "testimony", and "testing" which also appear in the
sample data. There is no "test" in the sample data, but if there
was, this query would not have found it.</p>
</li>
</ul>
<p><em>solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content[. ftcontains "test." 
  with wildcards]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(./content ftcontains "test." 
with wildcards)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Usability Testing&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some <span class=
"found">tests</span> of the site with your unique 
            audience or audiences by conducting usability 
            testing.&lt;/p&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt;   
   &lt;/content&gt;
&lt;/book&gt;      

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability <span class=
"found">tests</span> on Web sites. Usability 
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         &lt;p&gt;This book has not been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting Usability 
            <span class="found">Tests</span>&lt;/title&gt; 
             ...
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability <span class=
"found">Tests</span>&lt;/title&gt;  
            ...  
         &lt;/chapter&gt;
         ...  
      &lt;/part&gt;      
      ...                                         
   &lt;/content&gt; 
&lt;/book&gt;     
   
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
     &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Writings by Usabilityguy
            &lt;/componentTitle&gt;
            &lt;subComponent&gt;
               &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
               1996&lt;/componentDate&gt;
               &lt;/componentTitle&gt; 
               ...
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How to Evaluate Results from 
                  User <span class=
"found">Tests</span>."&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt;
               ...
            &lt;/subComponent&gt;
            ...
         &lt;/component&gt;
         ...
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="wildcard-queries-results-q2" id=
"wildcard-queries-results-q2"></a>5.2.2 Q2 Zero or One Character
Prefix Wildcard Query</h4>
<p>Find all books with the word "way" with no prefix or a one
character prefix in the text.</p>
<p>This query finds a word with no prefix or a one character prefix
(zero or one character before the first character).</p>
<ul>
<li>
<p>Operands: "way"</p>
</li>
<li>
<p>Functionality: word query, character wildcard (prefix) (0 or
1)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: There is no "way" in the sample data but if there was,
this query would have found it.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains ".?way" 
   with wildcards]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains ".?way" 
with wildcards)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ... 
         &lt;p&gt;Expert reviews and usability testing are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them <span class=
"found">away</span> from your site.&lt;/p&gt;
         ...                
      &lt;/introduction&gt;
      ...
   &lt;/content&gt;     
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="wildcard-queries-results-q3" id=
"wildcard-queries-results-q3"></a>5.2.3 Q3 Zero or More Character
Infix Wildcard Query</h4>
<p>Find all books with the words "serve" or "service" in the
text.</p>
<p>This query finds words with no infix character or any number of
infix characters (zero or more characters inserted in the middle of
a word).</p>
<ul>
<li>
<p>Operands: "serv", "e"</p>
</li>
<li>
<p>Functionality: word query, character wildcard (infix) (0 or
more)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title/text(), ./content</p>
</li>
<li>
<p>Comments: This query returns the word "service" and would return
the word "serve" if it existed in the sample data. It does not
return the word "served" which exists in the sample data.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains "serv.*e" 
   with wildcards]
where count($cont)&gt;0
return ($book/@number, $book/metadata/title/text(), $cont)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains "serv.*e" 
with wildcards)&gt;0]/(@number|./metadata/title/text()
|./content)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;&lt;/book&gt;
&lt;title&gt;Improving the Usability of a Web Site Through 
Expert Reviews and Usability Testing&lt;/title&gt;
&lt;content&gt;
   ...      
   &lt;part number="2"&gt;
      &lt;chapter&gt;
        &lt;title&gt;Usability Testing&lt;/title&gt;
        ...
        &lt;p&gt;Then changes are made to improve <span class=
"found">service</span> to 
        users.&lt;/p&gt;
      &lt;/chapter&gt;
   &lt;/part&gt; 
&lt;/content&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="wildcard-queries-results-q4" id=
"wildcard-queries-results-q4"></a>5.2.4 Q4 One or More Character
Suffix Wildcard Query on Part of a Word</h4>
<p>Find all books with the phrases "usability testing" or "user
testing" in the text.</p>
<p>This query finds a phrase allowing a suffix of one or more
characters (one or more characters after the last character) on a
part of one of the words.</p>
<ul>
<li>
<p>Operands: "us testing"</p>
</li>
<li>
<p>Functionality: phrase query, character wildcard (suffix) (1 or
more)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title/text(), ./content</p>
</li>
<li>
<p>Comments: This is a suffix query on a part of a word "us" which
is not one of the words or one of the roots of the words desired in
the results. The query on "us" will find "usability" and "user".
Where stemmed queries (Section 6 (STEMMING)) attempt to return
linguistic variants of a word or the root of a word, wildcards may
be applied to any part of a word and will return all character
combinations found.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains "us.+ testing" 
   with wildcards]
where count($cont)&gt;0
return ($book/@number, $book/metadata/title/text(), $cont)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains "us.+ testing" 
with wildcards)&gt;0]/(@number|./metadata/title/text()|./content)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;&lt;/book&gt;  
&lt;title&gt;Improving the Usability of a Web Site Through 
Expert Reviews and Usability Testing&lt;/title&gt;
&lt;content&gt;
   &lt;introduction&gt;
      ...
      &lt;p&gt;Expert reviews and <span class=
"found">usability testing</span> are 
      methods of identifying problems in layout, 
      terminology, and navigation before they frustrate
      users and drive them away from your site.&lt;/p&gt;
      ...
   &lt;/introduction&gt;
   ...
   &lt;part number="2"&gt;
      ...
      &lt;chapter&gt;
         &lt;title&gt;<span class=
"found">Usability Testing</span>&lt;/title&gt;
         &lt;p&gt;Once the problems identified by expert 
         reviews have been corrected, it is time to 
         conduct some tests of the site with your unique 
         audience or audiences by conducting <span class=
"found">usability</span> 
         <span class="found">testing</span>.&lt;/p&gt;
         ...
      &lt;/chapter&gt;
   &lt;/part&gt; 
&lt;/content&gt;
   
&lt;book number="2"&gt;&lt;/book&gt;  
&lt;title&gt;Usability Basics: How to Plan for and Conduct 
Usability Tests on Web Site Thereby Improving the 
Usability of Your Web Site&lt;/title&gt; 
&lt;content&gt;
   &lt;introduction&gt;
      &lt;p&gt;This is a basic handbook for planning and 
      conducting usability tests on Web sites. <span class=
"found">Usability</span>
      <span class=
"found">testing</span> should be used in conjunction with other 
      expert review methods.&lt;/p&gt;
      ...
   &lt;/introduction&gt;
   &lt;part number="1"&gt;
      ...
      &lt;chapter&gt;
         &lt;p&gt;Take the following steps to plan <span class=
"found">usability</span>
         <span class=
"found">testing</span>. &lt;step number="1"&gt;Clarify and 
         articulate the goal of the <span class=
"found">usability testing</span>. 
         &lt;step number="1"&gt;Clarify and 
         articulate the goal of the usability testing.
         &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
         are critical for users to be able to complete 
         successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
         a script of questions or instructions which 
         will prompt the user to attempt those 
         tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
         users and begin recruiting them.&lt;/step&gt; &lt;step 
         number="5"&gt;Conduct a pretest on a few users.
         &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
         on insights gleaned from the pretest.&lt;/step&gt; 
         &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
      &lt;/chapter&gt;
   &lt;/part&gt;
   &lt;part number="2"&gt;
      &lt;chapter&gt;
         &lt;title&gt;Conducting Usability Tests&lt;/title&gt; 
         ...
         &lt;p&gt;Give the user the script, then assure them 
         that you are testing the Web site, not them. 
         Users are asked to verbalize their thoughts as 
         they complete the tasks. The event is recorded 
         or someone takes notes. It is often preferable 
         to have two testers, &lt;footnote&gt;<span class=
"found">Usability</span>
         <span class=
"found">testing</span> can be done at great expense or on a 
         shoe string, using &lt;testingProcedure&gt;in-house 
         expertise&lt;/testingProcedure&gt; or 
         &lt;testingProcedure&gt;contracting with human 
         computer interaction professionals
         &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
         questions, another to take notes. Testers should 
         offer no guidance or comments to the user. Mouse 
         movements, typing, expressions, and the user's 
         words should be recorded.&lt;/p&gt;
      &lt;/chapter&gt;
      ...
   &lt;/part&gt;
&lt;/content&gt;

&lt;book number="3"&gt;&lt;/book&gt;  
&lt;title&gt;John Wesley Usabilityguy: A Register of His 
Papers&lt;/title&gt;   
&lt;content&gt;
   ...
   &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
      &lt;title&gt;Writings File, 
      &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
      &lt;/title&gt;
      ...
      &lt;component&gt;
         &lt;componentTitle&gt;Writings by Usabilityguy
         &lt;/componentTitle&gt;
         &lt;subComponent&gt;
            &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
            1996&lt;/componentDate&gt;
            &lt;/componentTitle&gt; 
            &lt;subsubComponent&gt;
               &lt;componentTitle&gt;"How Many Users Are Enough 
               for <span class=
"found">User Testing</span>?"&lt;/componentTitle&gt;
            &lt;/subsubComponent&gt; 
            ...
            &lt;subsubComponent&gt;
               &lt;subsubComponent&gt;&lt;componentTitle&gt;"Do-It-
               Yourself <span class="found">User Testing</span>"
               &lt;/componentTitle&gt;
            &lt;/subsubComponent&gt; 
         &lt;/subComponent&gt;
      &lt;/component&gt;
      ...
   &lt;/part&gt;      
&lt;/content&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="wildcard-queries-results-q5" id=
"wildcard-queries-results-q5"></a>5.2.5 Q5 Specified Range of
Characters Suffix Wildcard Query</h4>
<p>Find all books with the word "test" with a three to four
character suffix in the text.</p>
<p>This query finds a word with a number of characters within a
specified range in a suffix (specified range of characters after
the last character).</p>
<ul>
<li>
<p>Operands: "test"</p>
</li>
<li>
<p>Functionality: word query, character wildcard (suffix) (3 to
4)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: ./@number, ./content</p>
</li>
<li>
<p>Comments: This query allows any three or four character suffix.
It returns "testers" and "testing", but not "pretest" "tests" and
"tested" which also appear in the sample data. There is no "test"
in the sample data, but if there was, this query would not have
found it.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains "test.{3,4}" 
   with wildcards]
where count($cont)&gt;0
return ($book/@number, $cont)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(./content ftcontains "test.{3,4}" 
with wildcards)&gt;0]/(@number|./content)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;&lt;/book&gt;
&lt;content&gt;
   &lt;introduction&gt;
      ...
      &lt;p&gt;Expert reviews and usability <span class=
"found">testing</span> are 
      methods of identifying problems in layout, 
      terminology, and navigation before they frustrate
      users and drive them away from your site.&lt;/p&gt;
      ...
   &lt;/introduction&gt;
   ...
   &lt;part number="2"&gt;
      &lt;chapter&gt;
         &lt;title&gt;Usability <span class=
"found">Testing</span>&lt;/title&gt;
         &lt;p&gt;Once the problems identified by expert 
         reviews have been corrected, it is time to 
         conduct some tests of the site with your unique 
         audience or audiences by conducting usability 
         <span class="found">testing</span>.&lt;/p&gt;
         ...
      &lt;/chapter&gt;
   &lt;/part&gt; 
&lt;/content&gt;
                                                
&lt;book number="2"&gt;&lt;/book&gt;
&lt;content&gt;
   &lt;introduction&gt;
      &lt;p&gt;This is a basic handbook for planning and 
      conducting usability tests on Web sites. Usability
      <span class=
"found">testing</span> should be used in conjunction with other 
      expert review methods.&lt;/p&gt;
      ...
   &lt;/introduction&gt;
   &lt;part number="1"&gt;
      &lt;chapter&gt;
         &lt;p&gt;Take the following steps to plan &gt;usability
         <span class=
"found">testing</span>. &lt;step number="1"&gt;Clarify and 
         articulate the goal of the &gt;usability <span class=
"found">testing</span>. 
         &lt;step number="1"&gt;Clarify and 
         articulate the goal of the usability testing.
         &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
         are critical for users to be able to complete 
         successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
         a script of questions or instructions which 
         will prompt the user to attempt those 
         tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
         users and begin recruiting them.&lt;/step&gt; &lt;step 
         number="5"&gt;Conduct a pretest on a few users.
         &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
         on insights gleaned from the pretest.&lt;/step&gt; 
         &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
      &lt;/chapter&gt;
   &lt;/part&gt;
   &lt;part number="2"&gt;
      &lt;chapter&gt;
         &lt;title&gt;Conducting Usability Tests&lt;/title&gt; 
         ...
         &lt;p&gt;Give the user the script, then assure them 
         that you are testing the Web site, not them. 
         Users are asked to verbalize their thoughts as 
         they complete the tasks. The event is recorded 
         or someone takes notes. It is often preferable 
         to have two <span class=
"found">testers</span>, &lt;footnote&gt;Usability
         <span class=
"found">testing</span> can be done at great expense or on a 
         shoe string, using &lt;testingProcedure&gt;in-house 
         expertise&lt;/testingProcedure&gt; or 
         &lt;testingProcedure&gt;contracting with human 
         computer interaction professionals
         &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
         questions, another to take notes. <span class=
"found">Testers</span> should 
         offer no guidance or comments to the user. Mouse 
         movements, typing, expressions, and the user's 
         words should be recorded.&lt;/p&gt;
      &lt;/chapter&gt;
      &lt;chapter&gt;
         &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
         &lt;p&gt;Compile the results and review collectively. 
         Make changes to the site to alleviate the problems 
         found in Web site components which were propagating 
         the largest number of or the most devastating errors. 
         Begin new iterations of <span class=
"found">testing</span> and changes, until 
         users are successful in the accomplishing the 
         tasks.&lt;/p&gt;
      &lt;/chapter&gt;
   &lt;/part&gt;
&lt;/content&gt;

&lt;book number="3"&gt;&lt;/book&gt;
&lt;content&gt;
   ...
   &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
      &lt;title&gt;Writings File, 
      &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
      &lt;/title&gt;
      ...
      &lt;component&gt;
         &lt;componentTitle&gt;Writings by Usabilityguy
         &lt;/componentTitle&gt;
         &lt;subComponent&gt;
            &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
            1996&lt;/componentDate&gt;
            &lt;/componentTitle&gt; 
            &lt;subsubComponent&gt;
               &lt;componentTitle&gt;"How Many Users Are Enough 
               for User <span class=
"found">Testing</span>?"&lt;/componentTitle&gt;
            &lt;/subsubComponent&gt; 
            ...
            &lt;subsubComponent&gt;
               &lt;componentTitle&gt;"When Are You Done <span class="found">Testing</span>?"
               &lt;/componentTitle&gt;
            &lt;/subsubComponent&gt;
            &lt;subsubComponent&gt;
               &lt;componentTitle&gt;"Do-It-Yourself User <span class="found">Testing</span>"
               &lt;/componentTitle&gt;
            &lt;/subsubComponent&gt; 
         &lt;/subComponent&gt;
      &lt;/component&gt;
      ...
   &lt;/part&gt;      
&lt;/content&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Stemming" id="Stemming"></a>6 Use Case "STEMMING":
Word Stemming Queries</h2>
<div class="div2">
<h3><a name="stemming-description" id=
"stemming-description"></a>6.1 Description</h3>
<p>These use cases invoke a stemming algorithm (e.g., Porter) which
returns noun, verb, adjective, and adverb forms of a word or root
of a word in singular and plural.</p>
</div>
<div class="div2">
<h3><a name="stemming-queries-results" id=
"stemming-queries-results"></a>6.2 Queries and Results</h3>
<div class="div3">
<h4><a name="stemming-queries-results-q1" id=
"stemming-queries-results-q1"></a>6.2.1 Q1 Query Stemming on Word
Root</h4>
<p>Find all books with the word "test" in the text.</p>
<p>This query finds a word and its variants applying a stemming
algorithm.</p>
<ul>
<li>
<p>Operands: "test"</p>
</li>
<li>
<p>Functionality: word query, stemming</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: Unlike the wildcard queries in Section 5 (WILDCARD)
which allow any suffix, this query will not return the word
"testimony" which occurs in the sample data.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains "test" 
   with stemming]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains "test" 
with stemming)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ...
         &lt;p&gt;Expert reviews and usability <span class=
"found">testing</span> are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them away from your site.&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      ...
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Usability <span class=
"found">Testing</span>&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some <span class=
"found">tests</span> of the site with your unique 
            audience or audiences by conducting usability 
            <span class="found">testing</span>.&lt;/p&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt;                                                   

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability <span class=
"found">tests</span> on Web sites. Usability 
         <span class=
"found">testing</span> should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting Usability 
            <span class="found">Tests</span>&lt;/title&gt; 
            &lt;p&gt;Take the following steps to plan usability 
            <span class=
"found">testing</span>. &lt;step number="1"&gt;Clarify and 
            articulate the goal of the usability <span class=
"found">testing</span>.
            &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
            are critical for users to be able to complete 
            successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
            a script of questions or instructions which 
            will prompt the user to attempt those 
            tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
            users and begin recruiting them.&lt;/step&gt; &lt;step 
            number="5"&gt;Conduct a pretest on a few users.
            &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
            on insights gleaned from the pretest.&lt;/step&gt; 
            &lt;step number="7"&gt;Resume <span class=
"found">testing</span>.&lt;/step&gt;&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability <span class=
"found">Tests</span>&lt;/title&gt; 
            &lt;p&gt;Users can be <span class=
"found">tested</span> at any computer 
            workstation &lt;footnote&gt;They may be more 
            comfortable at their own workstation than in 
            a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
            &lt;p&gt;Give the user the script, then assure them 
            that you are <span class=
"found">testing</span> the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two <span class=
"found">testers</span>, &lt;footnote&gt;Usability 
            <span class=
"found">testing</span> can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. <span class=
"found">Testers</span> should 
            offer no guidance or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in Web site components which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of <span class=
"found">testing</span> and changes, until  
            users are successful in the accomplishing the 
            tasks.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;    

&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Writings by Usabilityguy
            &lt;/componentTitle&gt;
            &lt;subComponent&gt;
               &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
               1996&lt;/componentDate&gt;
               &lt;/componentTitle&gt; 
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How Many Users Are Enough 
                  for User <span class=
"found">Testing</span>?"&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How to Evaluate Results from 
                  User <span class=
"found">Tests</span>."&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt;
               &lt;subsubComponent&gt;
                  &lt;container type="box"&gt;5&lt;/container&gt;
                  &lt;componentTitle&gt;"When Are You Done <span class="found">Testing</span>?
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt;
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"Do-It-Yourself User <span class="found">Testing</span>"
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
            &lt;/subComponent&gt;
         &lt;/component&gt;
         ...
      &lt;/part&gt;   
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="stemming-queries-results-q2" id=
"stemming-queries-results-q2"></a>6.2.2 Q2 Query Stemming on
Multiple Word Roots</h4>
<p>Find all books with the phrases "usability testing" or "user
testing" in the text.</p>
<p>This query finds phrases applying a stemming algorithm to
selected words within the phrases.</p>
<ul>
<li>
<p>Operands: "usability testing" "use testing"</p>
</li>
<li>
<p>Functionality: phrase queries, stemming</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title/text(), ./content</p>
</li>
<li>
<p>Comments: This query applies stemming to one word in a phrase.
Unlike the wildcard queries in Section 5 (WILDCARD) which allow any
suffix, a stemmed query on "us" will not return "user" and
"usability", because they do not share the share root. This query
uses an <code>or</code> query introduced in Section 10
(LOGICAL).</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains 
   (("usable" with stemming) ftand "testing" phrase) 
   ftor (("use" with stemming) ftand "testing" phrase)]
where count($cont)&gt;0
return ($book/@number, $book/metadata/title/text(), $cont)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains (("usable" with stemming) 
ftand "testing" phrase) ftor (("use" with stemming) 
ftand "testing" phrase))&gt;0]/(@number|./metadata/title/text()
|./content)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;&lt;/book&gt;  
&lt;title&gt;Improving the Usability of a Web Site Through 
Expert Reviews and Usability Testing&lt;/title&gt;
&lt;content&gt;
   &lt;introduction&gt;
      ...
      &lt;p&gt;Expert reviews and <span class=
"found">usability testing</span> are 
      methods of identifying problems in layout, 
      terminology, and navigation before they frustrate
      users and drive them away from your site.&lt;/p&gt;
      ...
   &lt;/introduction&gt;
   ...
   &lt;part number="2"&gt;
      &lt;chapter&gt;
         &lt;title&gt;<span class=
"found">Usability Testing</span>&lt;/title&gt;
         &lt;p&gt;Once the problems identified by expert 
         reviews have been corrected, it is time to 
         conduct some tests of the site with your unique 
         audience or audiences by conducting <span class=
"found">usability</span> 
         <span class="found">testing</span>.&lt;/p&gt;
         ...
      &lt;/chapter&gt;
   &lt;/part&gt; 
&lt;/content&gt;
    
&lt;book number="2"&gt;&lt;/book&gt;  
&lt;title&gt;Usability Basics: How to Plan for and Conduct 
Usability Tests on Web Site Thereby Improving the 
Usability of Your Web Site&lt;/title&gt; 
&lt;content&gt;
   &lt;introduction&gt;
      &lt;p&gt;This is a basic handbook for planning and 
      conducting usability tests on Web sites. <span class=
"found">Usability</span>
      <span class=
"found">testing</span> should be used in conjunction with other 
      expert review methods.&lt;/p&gt;
      ...
   &lt;/introduction&gt;
   &lt;part number="1"&gt;
      &lt;chapter&gt;
         &lt;p&gt;Take the following steps to plan <span class=
"found">usability</span>
      <span class=
"found">testing</span>. &lt;step number="1"&gt;Clarify and 
          articulate the goal of the <span class=
"found">usability testing</span>. 
         &lt;step number="1"&gt;Clarify and 
         articulate the goal of the usability testing.
         &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
         are critical for users to be able to complete 
         successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
         a script of questions or instructions which 
         will prompt the user to attempt those 
         tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
         users and begin recruiting them.&lt;/step&gt; &lt;step 
         number="5"&gt;Conduct a pretest on a few users.
         &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
         on insights gleaned from the pretest.&lt;/step&gt; 
         &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
      &lt;/chapter&gt;
   &lt;/part&gt;
   &lt;part number="2"&gt;
      &lt;chapter&gt;
         &lt;title&gt;Conducting Usability Tests&lt;/title&gt; 
         ...
         &lt;p&gt;Give the user the script, then assure them 
         that you are testing the Web site, not them. 
         Users are asked to verbalize their thoughts as 
         they complete the tasks. The event is recorded 
         or someone takes notes. It is often preferable 
         to have two testers, &lt;footnote&gt;<span class=
"found">Usability</span>
         <span class=
"found">testing</span> can be done at great expense or on a 
         shoe string, using &lt;testingProcedure&gt;in-house 
         expertise&lt;/testingProcedure&gt; or 
         &lt;testingProcedure&gt;contracting with human 
         computer interaction professionals
         &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
         questions, another to take notes. Testers should 
         offer no guidance or comments to the user. Mouse 
         movements, typing, expressions, and the user's 
         words should be recorded.&lt;/p&gt;
      &lt;/chapter&gt;
      ...
   &lt;/part&gt;
&lt;/content&gt;

&lt;book number="3"&gt;&lt;/book&gt;  
&lt;title&gt;John Wesley Usabilityguy: A Register of His 
Papers&lt;/title&gt;   
&lt;content&gt;
   ...
   &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
      &lt;title&gt;Writings File, 
      &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
      &lt;/title&gt;
      ...
      &lt;component&gt;
         &lt;componentTitle&gt;Writings by Usabilityguy
         &lt;/componentTitle&gt;
         &lt;subComponent&gt;
            &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
            1996&lt;/componentDate&gt;
            &lt;/componentTitle&gt; 
            &lt;subsubComponent&gt;
               &lt;componentTitle&gt;"How Many Users Are Enough 
               for <span class=
"found">User Testing</span>?"&lt;/componentTitle&gt;
            &lt;/subsubComponent&gt; 
            ...
            &lt;subsubComponent&gt;
               &lt;subsubComponent&gt;&lt;componentTitle&gt;"Do-It-
               Yourself <span class="found">User Testing</span>"
               &lt;/componentTitle&gt;
            &lt;/subsubComponent&gt; 
         &lt;/subComponent&gt;
      &lt;/component&gt;
      ...
   &lt;/part&gt;      
&lt;/content&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Thesaurus" id="Thesaurus"></a>7 Use Case "THESAURUS":
Queries Which Use Thesauri, Dictionaries, and Taxonomies</h2>
<div class="div2">
<h3><a name="thesaurus-description" id=
"thesaurus-description"></a>7.1 Description</h3>
<p>These use cases illustrate queries which return synonyms or
related words identified by thesauri, dictionaries, and
taxonomies.</p>
</div>
<div class="div2">
<h3><a name="thesaurus-queries-results" id=
"thesaurus-queries-results"></a>7.2 Queries and Results</h3>
<div class="div3">
<h4><a name="thesaurus-queries-results-q1" id=
"thesaurus-queries-results-q1"></a>7.2.1 Q1 Query on Synonyms
Identified by a Thesaurus</h4>
<p>Find all introductions which quote someone.</p>
<p>This query finds words and phrases using a thesaurus to return
synonyms.</p>
<ul>
<li>
<p>Operands: "quote"</p>
</li>
<li>
<p>Functionality: word query, thesaurus support</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .//introduction</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query uses thesaurus support to identify synonyms
for the word "quote" via preferred and used for terms: "said",
"says", "stated", "states", "spoke", "speaks", "replied",
"replies", "reply", "remarks", "remarked", "responded", "response",
"reports", "reported", "quotes", "quoted", "according to",
"commented", "discussed", "expressed", and "told". These words and
phrases become additional operands.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $intro := $book//introduction[. ftcontains "quote" 
   with thesaurus at
   "http://bstore1.example.com/UsabilityThesaurus.xml" 
   relationship "synonyms"]
where count($intro)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//introduction ftcontains "quote" 
with thesaurus at 
"http://bstore1.example.com/UsabilityThesaurus.xml" 
relationship "synonyms")&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;introduction&gt;
         ...
         &lt;p&gt;The most successful projects employ multiple 
         methods in multiple iterations. As Millicent 
         Marigold <span class=
"found">remarked</span> during a recent conference, 
         "Don't stop. Iterate, iterate, then iterate 
         again."&lt;/p&gt;
         ...
      &lt;/introduction&gt;
   &lt;/content&gt;      
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="thesaurus-queries-results-q2" id=
"thesaurus-queries-results-q2"></a>7.2.2 Q2 Query on Narrower Terms
Identified by a Thesaurus</h4>
<p>Find all books with text on improving "web site components".</p>
<p>This query finds words using a thesaurus to identify narrower
terms.</p>
<ul>
<li>
<p>Operands: "web site components"</p>
</li>
<li>
<p>Functionality: phrase query, thesaurus support</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query employs a thesaurus to identify web site
components via narrower terms: "layout", "terminology", "graphics",
"menus", and "navigation". These words become additional
operands.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content[. ftcontains "web site components" 
   with thesaurus at 
   "http://bstore1.example.com/UsabilityThesaurus.xml" 
   relationship "narrower terms" at most 2 levels]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(./content ftcontains "web site components" 
with thesaurus at 
"http://bstore1.example.com/UsabilityThesaurus.xml" 
relationship "narrower terms" at most 2 levels)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ...   
         &lt;p&gt;Expert reviews and usability testing are 
         methods of identifying problems in <span class=
"found">layout</span>, 
         <span class="found">terminology</span>, and <span class=
"found">navigation</span> before they frustrate
         users and drive them away from your site.&lt;/p&gt; 
         ... 
      &lt;/introduction&gt;                   
      ... 
   &lt;/content&gt;  
&lt;/book&gt;   
      
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ... 
      &lt;part number="2"&gt;
         ...
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt;   
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in <span class=
"found">Web site components</span> which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of testing and changes, until 
            users are successful in the accomplishing the 
            tasks.&lt;/p&gt;  
         &lt;/chapter&gt;
      &lt;/part&gt;       
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="thesaurus-queries-results-q3" id=
"thesaurus-queries-results-q3"></a>7.2.3 Q3 Query on Broader Terms
Identified by a Thesaurus</h4>
<p>Are there any "letters" or "holiday cards" in John Wesley
Usabilityguy's papers?</p>
<p>This query finds words and phrases using a thesaurus to identify
broader terms.</p>
<ul>
<li>
<p>Operands: "letters" "holiday cards"</p>
</li>
<li>
<p>Functionality: word query, phrase query, thesaurus support</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book[@number="3"]</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query employs a thesaurus to identify the broader
term "correspondence". It becomes an additional operand.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[@number="3"]
let $cont := $book/content[. ftcontains 
   "letters" ftor "holiday cards" with thesaurus at 
   "http://bstore1.example.com/UsabilityThesaurus.xml" 
   relationship "BT" exactly 1 levels]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(./content ftcontains "letters" 
ftor "holiday cards" with thesaurus at 
"http://bstore1.example.com/UsabilityThesaurus.xml" 
relationship "BT" exactly 1 levels)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of software 
         applications and usability specialist. The collection 
         consists of <span class=
"found">correspondence</span>, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;<span class=
"found">Correspondence</span>, telegrams, memoranda, journals, 
            logs, testimony, approved travel orders, invitations, 
            charts, graphs, forms, biographical data, photographs, 
            book drafts, clippings and other printed matter, 
            résumés and miscellaneous material. Organized by 
            name of person or organization, topic, or type of 
            material.&lt;/p&gt;
         &lt;/introduction&gt;            
      &lt;/part&gt;
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;<span class=
"found">Correspondence</span>, articles, book drafts, notes,
            contracts, clippings, and printed matter. Arranged 
            alphabetically by type (articles, books, reports, 
            and miscellaneous) and therein alphabetically by 
            type of material, subject, or title.&lt;/p&gt;
         &lt;/introduction&gt;    
         ...        
      &lt;/part&gt;
   &lt;/content&gt;    
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="thesaurus-queries-results-q4" id=
"thesaurus-queries-results-q4"></a>7.2.4 Q4 Query on Word Which
Sounds Like Other Words</h4>
<p>Find all books with words which sound like "Merrygould".</p>
<p>This query finds words using a dictionary of words which sound
like the word queried.</p>
<ul>
<li>
<p>Operands: "Merrygould"</p>
</li>
<li>
<p>Functionality: word query, sounds-like dictionary support</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query uses sounds-like support to identify words
which sound like the word "Merrygould". It returns the word
"Marigold". Examples of how this query is implemented include
keeping a list of similar words (akin to a thesaurus) or using a
system based on phonetic similarity.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[. ftcontains "Merrygould" 
   with thesaurus at 
   "http://bstore1.example.com/UsabilitySoundex.xml" 
   relationship "sounds like"]
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[. ftcontains "Merrygould" 
with thesaurus at 
"http://bstore1.example.com/UsabilitySoundex.xml" 
relationship "sounds like"&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
      the Usability of a Web Site Through Expert Reviews and 
      Usability Testing&lt;/title&gt;
      &lt;author&gt;Millicent <span class=
"found">Marigold</span>&lt;/author&gt;
      &lt;author&gt;Montana <span class=
"found">Marigold</span>&lt;/author&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         ...
         &lt;p&gt;The most successful projects employ multiple 
         methods in multiple iterations. As Millicent 
         <span class=
"found">Marigold</span> remarked during a recent conference, 
         "Don't stop. Iterate, iterate, then iterate 
         again."&lt;/p&gt;
         ...
      &lt;/introduction&gt;
   &lt;/content&gt;   
&lt;/book&gt;
   
&lt;book number="3"&gt;
   &lt;metadata&gt;
      &lt;title shortTitle="Usabilityguy Manuscript 
      Guide"&gt;John Wesley Usabilityguy: A Register of His 
      Papers&lt;/title&gt;
      &lt;author&gt;Millicent <span class=
"found">Marigold</span>&lt;/author&gt;
      &lt;author&gt;Morty <span class=
"found">Marigold</span>&lt;/author&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...   
   &lt;/content&gt;   
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="thesaurus-queries-results-q5" id=
"thesaurus-queries-results-q5"></a>7.2.5 Q5 Query on Word Spelled
Similarly to Other Words</h4>
<p>Find all books which contain words that are close in spelling to
"sucessfull".</p>
<p>This query finds words using a dictionary of words that are
spelled similarly.</p>
<ul>
<li>
<p>Operands: "sucessfull"</p>
</li>
<li>
<p>Functionality: word query, similarly spelled dictionary
support</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query uses support for similarly spelled words to
identify words close in spelling to "sucessfull". It returns the
word "successful". Examples of how this query is implemented
include keeping a list of similar words (akin to a thesaurus) or
using a system based on spelling similarities.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[. ftcontains "sucessfull" 
   with thesaurus at 
   "http://bstore1.example.com/spellcheck.xml" 
   relationship "misspelling of"]
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[. ftcontains "sucessfull" 
with thesaurus at 
"http://bstore1.example.com/spellcheck.xml" 
relationship "misspelling of"&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;introduction&gt;
         ...
         &lt;p&gt;The most <span class=
"found">successful</span> projects employ multiple 
         methods in multiple iterations. As Millicent 
         Marigold remarked during a recent conference, 
         "Don't stop. Iterate, iterate, then iterate 
         again."&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         ...
         &lt;chapter&gt;
            &lt;title&gt;Cognitive Walk-Through&lt;/title&gt;
            &lt;p&gt;Expert reviewers evaluate Web site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "Would a 
            user know by looking at the screen how to 
            complete the first step of the task?" and "If 
            the user completed the first step, would the 
            user know what to do next?," with the goal of 
            identifying any obstacles to completing the 
            task and assessing whether the user would 
            cognitively be aware that he was <span class=
"found">successful</span> in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;   
      ...
   &lt;/content&gt;  
&lt;/book&gt;    

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;
         ...
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in Web site components which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of testing and changes, until 
            users are <span class=
"found">successful</span> in the accomplishing the 
            tasks.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
   &lt;/content&gt;   
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="thesaurus-queries-results-q6" id=
"thesaurus-queries-results-q6"></a>7.2.6 Q6 Query on Subordinate
Terms Identified by a Taxonomy</h4>
<p>Find out whether John Wesley Usabilityguy included research on
"AIDS" and "other infectious diseases" among the charities he
supported.</p>
<p>This query finds words using a taxonomy to identify subordinate
terms.</p>
<ul>
<li>
<p>Operands: "AIDS"</p>
</li>
<li>
<p>Functionality: word query, case-sensitivity (limited to upper
case), taxonomy support</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book[@number="3"]</p>
</li>
<li>
<p>Query context: ./content/part/component</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query uses a taxonomy to identify other
infectious diseases: "Hepatitis" and "Tuberculosis". These words
become additional operands.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[@number="3"]
let $comp := $book//component[. ftcontains "AIDS" uppercase 
   with thesaurus at 
   "http://bstore1.example.com/OurTaxonomy.xml" 
   relationship "disease in this category"]
where count($comp)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[@number="3" and count(.//component ftcontains "AIDS" 
uppercase with thesaurus at 
"http://bstore1.example.com/OurTaxonomy.xml" 
relationship "disease in this category")&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="3"&gt; 
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Charitable Contributions
            &lt;/componentTitle&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Diseases: <span class=
"found">AIDS</span>, <span class="found">Hepatitis</span>, 
               <span class=
"found">Tuberculosis</span>&lt;componentDate normalize=
               "1990/1999"&gt;1990-1999&lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Environmental Conservation: 
               Rivers &lt;componentDate normalize="1995"&gt;1995
               &lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt;
         &lt;/component&gt;
      &lt;/part&gt;
   &lt;/content&gt;      
&lt;/book&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Stop-word" id="Stop-word"></a>8 Use Case "STOP-WORD":
Queries on Stop Words</h2>
<div class="div2">
<h3><a name="stop-word-description" id=
"stop-word-description"></a>8.1 Description</h3>
<p>These use cases query a phrase, one word of which has been
identified as a stop word via a stop word list. The first treats
the stop word as a stop word. The second does not, making it
available again for querying. Another query calls a stop word list
then excludes a word on the list making that word available for
querying.</p>
<p>Words identified as stop words may be routinely eliminated from
queries, allowing any word to be substituted.</p>
</div>
<div class="div2">
<h3><a name="Stop-word-queries-results" id=
"Stop-word-queries-results"></a>8.2 Queries and Results</h3>
<div class="div3">
<h4><a name="stop-word-queries-results-q1" id=
"stop-word-queries-results-q1"></a>8.2.1 Q1 Query on Stop Word
Treated as a Stop Word</h4>
<p>Find all books with the phrase "planning then conducting" in the
text where "then" is treated as a stop word.</p>
<p>This query finds a phrase substituting any word for a word which
has been identified as a stop word via a stop word list.</p>
<ul>
<li>
<p>Operands: "planning then conducting"</p>
</li>
<li>
<p>Functionality: stop word (then), phrase query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: Once the stop word "then" has been identified via the
stop word list at http://bstore1.example.com/StopWordList.xml, this
query is reduced to a query on the phrase "planning" any word
"conducting", allowing any word as a substitute for the stop word.
It finds both "planning and conducting" and "planning then
conducting" in the sample data.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains 
   "planning then conducting" with stop words 
   at "http://bstore1.example.com/StopWordList.xml"]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains "planning then 
conducting" with stop words at 
"http://bstore1.example.com/StopWordList.xml")&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for <span class=
"found">planning and</span> 
         <span class=
"found">conducting</span> usability tests on Web sites. Usability  
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         &lt;p&gt;This book has not been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;<span class=
"found">Planning then Conducting</span> Usability
            Tests&lt;/title&gt; 
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="stop-word-queries-results-q2" id=
"stop-word-queries-results-q2"></a>8.2.2 Q2 Query on Stop Word Not
Treated as a Stop Word</h4>
<p>Find all books with the phrase "planning then conducting" in the
text where "then" is not treated as a stop word.</p>
<p>This query does not eliminate a word from the query even though
it has been identified as a stop word in the stop word list, making
it available again for querying.</p>
<ul>
<li>
<p>Operands: "planning then conducting"</p>
</li>
<li>
<p>Functionality: stop word (then), phrase query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: Even though the word "then" has been identified as a
stop word, this query makes it available again for querying. It
finds only "planning then conducting" in the sample data.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains 
   "planning then conducting" without stop words]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains "planning then 
conducting" without stop words)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;<span class=
"found">Planning then Conducting</span> Usability
            Tests&lt;/title&gt; 
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="stop-word-queries-results-q3" id=
"stop-word-queries-results-q3"></a>8.2.3 Q3 Query Excluding a Stop
Word on a Stop Word List</h4>
<p>Find books with the phrase "not been approved" in the text.</p>
<p>This query finds a phrase substituting any words for words which
have been identified as stop words via a stop word list, removing
the word "not" temporarily from the stop word list.</p>
<ul>
<li>
<p>Operands: "not been approved"</p>
</li>
<li>
<p>Functionality: phrase query, stop word list (not, been), the
stop word "not" is excluded from the list and used in the query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: ./metadata/title, ./content</p>
</li>
<li>
<p>Comments: The stop words "not" and "been" are identified via a
stop word list, however the stop word "not" is removed temporarily
from the stop word list and used as an operand in the query. The
query becomes a query on the phrase "not" [any word] "approved",
allowing any word as a substitute for the stop word "been". It does
not return books with the word "approved" in the phrases "been
approved" and "approved travel orders" in the sample data.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content[. ftcontains 
   "not been approved" with stop words at
   "http://bstore1.example.com/StopWordList.xml" 
   except ("not")]
where count($cont)&gt;0
return ($book/metadata/title, $book/content)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(./content ftcontains "not been 
approved" with stop words at 
"http://bstore1.example.com/StopWordList.xml" 
except ("not"))&gt;0]/(./metadata/title|./content)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct 
Usability Tests on Web Site Thereby Improving the 
Usability of Your Web Site&lt;/title&gt;
&lt;content&gt;
   ...          
   &lt;p&gt;This book has <span class=
"found">not been approved</span> by the Web Site 
   Users Association&lt;/p&gt;
   ...     
&lt;/content&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Character" id="Character"></a>9 Use Case "CHARACTER":
Queries Specifying Normalized Forms of Characters and Tokenized
Words</h2>
<div class="div2">
<h3><a name="character-description" id=
"character-description"></a>9.1 Description</h3>
<p>These use cases illustrate queries on words entered with
diacritics sometimes finding the same; other times finding words
with and without diacritics. They query words entered in upper case
sometimes finding the same; other times finding words in both upper
and lower case.</p>
</div>
<div class="div2">
<h3><a name="character-queries-results" id=
"character-queries-results"></a>9.2 Queries and Results</h3>
<div class="div3">
<h4><a name="character-queries-results-q1" id=
"character-queries-results-q1"></a>9.2.1 Q1 Diacritics Sensitive
Query</h4>
<p>Verify the existence of a "résumé" in the papers of John Wesley
Usabilityguy.</p>
<p>This query finds a word only if it contains the diacritics as
written in the query.</p>
<ul>
<li>
<p>Operands: "résumé"</p>
</li>
<li>
<p>Functionality: word query, functionality requiring presence of
diacritics as written in the query, character wildcard (suffix)
(1)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: The desired results include only the words "résumé"
and "résumés" with diacritics as written in the query, not the more
often used words "resume" (which is present in the sample data) and
"resumes".</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains "résumé." 
   with wildcards diacritics sensitive]
where count($cont) &gt;0    
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains "résumé." 
with wildcards diacritics sensitive)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of software 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, <span class=
"found">résumés</span> and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Correspondence, telegrams, memoranda, journals, 
            logs, testimony, approved travel orders, invitations, 
            charts, graphs, forms, biographical data, photographs, 
            book drafts, clippings and other printed matter, 
            <span class=
"found">résumés</span> and miscellaneous material. Organized by 
            name of person or organization, topic, or type of 
            material.&lt;/p&gt;
         &lt;/introduction&gt;
         ...
      &lt;/part&gt;
      ...   
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="character-queries-results-q2" id=
"character-queries-results-q2"></a>9.2.2 Q2 Diacritics Insensitive
Query</h4>
<p>Verify the existence of a résumé in the papers of John Wesley
Usabilityguy.</p>
<p>This query finds a word whether diacritics are present or
not.</p>
<ul>
<li>
<p>Operands: "resume"</p>
</li>
<li>
<p>Functionality: word query, functionality finding words with and
without diacritics, character wildcard (suffix) (1)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: The desired results include either the words "résumé"
or "résumés" with diacritics or the words "resume" or "resumes"
without diacritics. Whether diacritics are written in the query or
not is not considered.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains "resume." 
   with wildcards diacritics insensitive]
where count($cont) &gt;0   
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains "resume." 
with wildcards diacritics insensitive)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting Usability 
            Tests&lt;/title&gt; 
            &lt;p&gt;Take the following steps to plan usability 
            testing. &lt;step number="1"&gt;Clarify and 
            articulate the goal of the usability testing.
            &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
            are critical for users to be able to complete 
            successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
            a script of questions or instructions which 
            will prompt the user to attempt those 
            tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
            users and begin recruiting them.&lt;/step&gt; &lt;step 
            number="5"&gt;Conduct a pretest on a few users.
            &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
            on insights gleaned from the pretest.&lt;/step&gt; 
            &lt;step number="7"&gt;<span class=
"found">Resume</span> testing.&lt;/step&gt;&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;  
      ... 
   &lt;/content&gt;
&lt;/book&gt;      
   
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of software 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, <span class=
"found">résumés</span> and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Correspondence, telegrams, memoranda, journals, 
            logs, testimony, approved travel orders, invitations, 
            charts, graphs, forms, biographical data, photographs, 
            book drafts, clippings and other printed matter, 
            <span class=
"found">résumés</span> and miscellaneous material. Organized by 
            name of person or organization, topic, or type of 
            material.&lt;/p&gt;
         &lt;/introduction&gt;
         ...
      &lt;/part&gt;
      ...   
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="character-queries-results-q3" id=
"character-queries-results-q3"></a>9.2.3 Q3 Query on Word with
Upper Case Characters</h4>
<p>Find out whether John Wesley Usabilityguy included research on
"AIDS" among the charities he supported.</p>
<p>This query finds a word in upper case characters.</p>
<ul>
<li>
<p>Operands: "AIDS"</p>
</li>
<li>
<p>Functionality: case-sensitivity (limited to upper case), word
query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query does not return the word "aids" with lower
case characters which exists in the sample data.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[. ftcontains "AIDS" uppercase]   
where count($book) &gt;0  
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(. ftcontains "AIDS" 
uppercase)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Charitable Contributions
            &lt;/componentTitle&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Diseases: <span class=
"found">AIDS</span>, Hepatitis, 
               Tuberculosis &lt;componentDate normalize=
               "1990/1999"&gt;1990-1999&lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt; 
            ...
         &lt;/component&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="character-queries-results-q4" id=
"character-queries-results-q4"></a>9.2.4 Q4 Query on Word with
Upper Case and Lower Case Characters</h4>
<p>Find out whether John Wesley Usabilityguy included research on
"AIDS" among the charities he supported.</p>
<p>This query finds a word with upper or lower case characters.</p>
<ul>
<li>
<p>Operands: "AIDS"</p>
</li>
<li>
<p>Functionality: word query, case-insensitivity</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query returns the word "aids" with characters in
upper or lower case.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[. ftcontains "AIDS" case insensitive]   
where count($book) &gt; 0  
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(. ftcontains "AIDS" case 
insensitive)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;Usability testing&lt;/subject&gt;
         &lt;subject&gt;Web site development&lt;/subject&gt;
         &lt;subject&gt;Guides and finding <span class=
"found">aids</span>&lt;/subject&gt;
      &lt;/subjects&gt;      
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
   &lt;/content&gt;   
&lt;/book&gt;     
   
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Charitable Contributions
            &lt;/componentTitle&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Diseases: <span class=
"found">AIDS</span>, Hepatitis, 
               Tuberculosis &lt;componentDate normalize=
               "1990/1999"&gt;1990-1999&lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt; 
            ...
         &lt;/component&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Logical" id="Logical"></a>10 Use Case "LOGICAL":
Queries with Logical Expressions (Or, And, and Not Queries)</h2>
<div class="div2">
<h3><a name="logical-description" id="logical-description"></a>10.1
Description</h3>
<p>These use cases include queries containing logical expressions:
<code>or</code>, <code>and</code>, the unary <code>not</code>,
<code>and not</code>, and <code>mild not</code>.</p>
</div>
<div class="div2">
<h3><a name="logical-queries-results" id=
"logical-queries-results"></a>10.2 Queries and Results</h3>
<div class="div3">
<h4><a name="logical-queries-results-q1" id=
"logical-queries-results-q1"></a>10.2.1 Q1 Or Query</h4>
<p>Find all books with the words "web" or "software" in the
text.</p>
<p>This query finds any or all of the words.</p>
<ul>
<li>
<p>Operands: "web" "software"</p>
</li>
<li>
<p>Functionality: word query, <code>or</code> query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comment: The <code>or</code> query returns any or all of words
queried.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains "web" 
   ftor "software"]
where fn:count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains 
"web" ftor "software")&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ...
         &lt;p&gt;The usability of a <span class=
"found">Web</span> site is how well the 
         site supports the user in achieving specified 
         goals. A <span class=
"found">Web</span> site should facilitate learning, 
         and enable efficient and effective task 
         completion, while propagating few errors. 
         Satisfaction with the site is also important. 
         The user must not only be well-served, but must 
         feel well-served.&lt;/p&gt; 
         ...
         &lt;p&gt;This book has been approved by the <span class=
"found">Web</span> Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Expert reviewers identify problems 
            and recommend changes to <span class=
"found">web</span> sites based 
            on research in human computer interaction 
            and their experience in the field.&lt;/p&gt; 
            ...
            &lt;p&gt;Expert review methods should be 
            initiated early in the development process, 
            as soon as paper &lt;b&gt;p&lt;/b&gt;rototypes 
            (hand-drawn pictures of <span class=
"found">Web</span> pages) or
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are 
            available. They should be conducted using 
            the hardware and <span class=
"found">software</span> similar to that  
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
         &lt;chapter&gt;
            &lt;title&gt;Heuristic Evaluation&lt;/title&gt;
            &lt;p&gt;Expert reviewers critique an interface to 
            determine conformance with recognized 
            usability principles. &lt;footnote&gt;One of the 
            best known lists of heuristics is &lt;citation 
            url="http://www.useit.com/papers/heuristic
            /heuristic_list.html"&gt;Ten Usability 
            Heuristics by Jacob Nielson&lt;/citation&gt;. Another 
            is &lt;citation url="http://usability.gov
            /guidelines/index.html"&gt; Research-Based <span class=
"found">Web</span>  
            Design and Usability Guidelines&lt;/citation&gt;
            &lt;/footnote&gt;&lt;/p&gt; 
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Cognitive Walk-Through&lt;/title&gt;
            &lt;p&gt;Expert reviewers evaluate <span class=
"found">Web</span> site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "Would a 
            user know by looking at the screen how to 
            complete the first step of the task?" and "If 
            the user completed the first step, would the 
            user know what to do next?," with the goal of 
            identifying any obstacles to completing the 
            task and assessing whether the user would 
            cognitively be aware that he was successful in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
        
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;     
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability tests on <span class=
"found">Web</span> sites. Usability 
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         &lt;p&gt;This book has not been approved by the <span class="found">Web</span> Site
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         ...
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability Tests&lt;/title&gt; 
            ...
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the <span class=
"found">Web</span> site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;Usability 
            testing can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no guidance or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in <span class=
"found">Web</span> site components which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of testing and changes, until 
            users are successful in the accomplishing the 
            tasks.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;    
   &lt;/content&gt;
&lt;/book&gt;        
    
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt; 
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of <span class=
"found">software</span> 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         ...
         &lt;component&gt;&lt;container type="box"&gt;1&lt;/container&gt;
           &lt;componentTitle&gt;Computers&lt;/componentTitle&gt;
           &lt;subComponent&gt;
              &lt;componentTitle&gt;<span class=
"found">Software</span>, 
              &lt;componentDate normalize="1946/1947"&gt;1946-1947
              &lt;/componentDate&gt;
              &lt;/componentTitle&gt;
           &lt;/subComponent&gt;   
           ...
         &lt;/component&gt;
         &lt;component&gt;
           &lt;componentTitle&gt;<span class=
"found">Web</span> User Appreciation Award, 
           &lt;componentDate normalize="1956"&gt;1956&lt;/componentDate&gt;
           &lt;/componentTitle&gt;
         &lt;/component&gt;
         ...
      &lt;/part&gt;  
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="logical-queries-results-q2" id=
"logical-queries-results-q2"></a>10.2.2 Q2 And Query</h4>
<p>Find all books with the words "web" "software" in the text.</p>
<p>This query finds all of the words.</p>
<ul>
<li>
<p>Operands: "web" "software"</p>
</li>
<li>
<p>Functionality: word queries, <code>and</code> query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: The <code>and</code> query finds all the words.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains "web" 
   ftand "software"]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains 
"web" ftand "software")&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;author&gt;Elina Rose&lt;/author&gt;
         &lt;p&gt;The usability of a <span class=
"found">Web</span> site is how well the 
         site supports the user in achieving specified 
         goals. A <span class=
"found">Web</span> site should facilitate learning, 
         and enable efficient and effective task 
         completion, while propagating few errors. 
         Satisfaction with the site is also important. 
         The user must not only be well-served, but must 
         feel well-served.&lt;/p&gt; 
         ...
         &lt;p&gt;This book has been approved by the <span class=
"found">Web</span> Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         &lt;introduction&gt;
             &lt;p&gt;Expert reviewers identify problems 
            and recommend changes to <span class=
"found">web</span> sites based 
            on research in human computer interaction 
            and their experience in the field.&lt;/p&gt; 
            ...
            &lt;p&gt;Expert review methods should be 
            initiated early in the development process, 
            as soon as paper &lt;b&gt;p&lt;/b&gt;rototypes 
            (hand-drawn pictures of <span class=
"found">Web</span> pages) or
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are 
            available. They should be conducted using 
            the hardware and <span class=
"found">software</span> similar to that  
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
         &lt;chapter&gt;
            &lt;title&gt;Heuristic Evaluation&lt;/title&gt;
            &lt;p&gt;Expert reviewers critique an interface to 
            determine conformance with recognized 
            usability principles. &lt;footnote&gt;One of the 
            best known lists of heuristics is &lt;citation 
            url="http://www.useit.com/papers/heuristic
            /heuristic_list.html"&gt;Ten Usability 
            Heuristics by Jacob Nielson&lt;/citation&gt;. Another 
            is &lt;citation url="http://usability.gov
            /guidelines/index.html"&gt; Research-Based <span class=
"found">Web</span>  
            Design and Usability Guidelines&lt;/citation&gt;
            &lt;/footnote&gt;&lt;/p&gt; 
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Cognitive Walk-Through&lt;/title&gt;
            &lt;p&gt;Expert reviewers evaluate <span class=
"found">Web</span> site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "Would a 
            user know by looking at the screen how to 
            complete the first step of the task?" and "If 
            the user completed the first step, would the 
            user know what to do next?," with the goal of 
            identifying any obstacles to completing the 
            task and assessing whether the user would 
            cognitively be aware that he was successful in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;   
    
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt; 
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of <span class=
"found">software</span> 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         ...
         &lt;component&gt;&lt;container type="box"&gt;1&lt;/container&gt;
           &lt;componentTitle&gt;Computers&lt;/componentTitle&gt;
           &lt;subComponent&gt;
              &lt;componentTitle&gt;<span class=
"found">Software</span>, 
              &lt;componentDate normalize="1946/1947"&gt;1946-1947
              &lt;/componentDate&gt;
              &lt;/componentTitle&gt;
           &lt;/subComponent&gt;   
           ...
         &lt;/component&gt;
         &lt;component&gt;
           &lt;componentTitle&gt;<span class=
"found">Web</span> User Appreciation Award, 
           &lt;componentDate normalize="1956"&gt;1956&lt;/componentDate&gt;
           &lt;/componentTitle&gt;
         &lt;/component&gt;
         ...
      &lt;/part&gt;  
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="logical-results-q3" id="logical-results-q3"></a>10.2.3
Q3 And Query Ordered</h4>
<p>Find all book text containing the words "goal" "obstacles"
"task" in this order.</p>
<p>This query finds multiple words in the order queried.</p>
<ul>
<li>
<p>Operands: "goal" "obstacles" "task"</p>
</li>
<li>
<p>Functionality: ordered word query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query finds multiple words in a specified order.
It is more permissive than a phrase query. It is comparable to an
ordered distance query where the number of intervening words is
zero or more.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains 
   "goal" ftand "obstacles" ftand "task" ordered]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains 
"goal" ftand "obstacles" ftand "task" ordered)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;                                    
   &lt;content&gt;
   ...
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;p&gt;Expert reviewers evaluate Web site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "Would a 
            user know by looking at the screen how to 
            complete the first step of the task?" and "If 
            the user completed the first step, would the 
            user know what to do next?," with the <span class=
"found">goal</span> of 
            identifying any <span class=
"found">obstacles</span> to completing the 
            <span class=
"found">task</span> and assessing whether the user would 
            cognitively be aware that he was successful in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="logical-queries-results-q4" id=
"logical-queries-results-q4"></a>10.2.4 Q4 Unary Not Query</h4>
<p>Find all books which do not belong in a collection on "usability
testing".</p>
<p>This query finds books which do not contain a phrase in an
element and its descendants.</p>
<ul>
<li>
<p>Operands: "usability testing"</p>
</li>
<li>
<p>Functionality: phrase query, character wildcard (suffix) (0 or
more), <code>unary not</code> query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: Unlike the <code>and not</code> query below, the
<code>unary not</code> query requires only one operand. This query
has value for information architects and data managers who will use
it for checks such as this one: to find nonconforming data in a
document or a collection.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $not := $book[. ftcontains ftnot "us.* testing"
   with wildcards]
where count($not) &gt; 0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(. ftcontains  ftnot "us.* testing" 
with wildcards)&gt;0]
</pre></div>
<p><em>Expected Result: No results returned.</em></p>
</div>
<div class="div3">
<h4><a name="logical-queries-results-q5" id=
"logical-queries-results-q5"></a>10.2.5 Q5 And Not Query</h4>
<p>Find all books with the word "usability" and not the word "plan"
in the metadata.</p>
<p>This query finds a word only when another is not found in an
element or its descendants.</p>
<ul>
<li>
<p>Operands: "usability" "plan"</p>
</li>
<li>
<p>Functionality: word query, <code>and not</code> query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: The <code>and not</code> query is also called a
<code>but</code>, <code>but not</code>, and <code>without</code>
query. Unlike the <code>unary not</code> query above,this query
requires two operands. Book 2 which contains the words "usability"
and "plan" in the metadata is not returned.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $up := $book[./metadata ftcontains "usability" 
   ftand ftnot "plan"]
where count($up) &gt; 0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(./metadata ftcontains "usability" 
ftand ftnot "plan")&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;                             
      &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
      the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
      and <span class=
"found">Usability</span> Testing&lt;/title&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
   ...   
   &lt;/content&gt;   
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;metadata&gt;     
      ...                       
      &lt;subjects xml:lang="en"&gt;
         ...  
         &lt;subject&gt;<span class=
"found">Usability</span> Testing&lt;/subject&gt;
         ... 
      &lt;/subjects&gt;  
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
   ...   
   &lt;/content&gt;   
&lt;/book&gt;


</pre></div>
</div>
<div class="div3">
<h4><a name="logical-queries-results-q6" id=
"logical-queries-results-q6"></a>10.2.6 Q6 And Not Query Where
Second Operand Is a Subset of the First Operand</h4>
<p>Find all books with listings for "résumés", "drafts", or
"correspondence", and not "book drafts" in the text.</p>
<p>This query finds books with multiple words and not a phrase
containing one of those words.</p>
<ul>
<li>
<p>Operands: "résumés" "drafts" "correspondence" "book drafts"</p>
</li>
<li>
<p>Functionality: word queries, <code>or</code> query, phrase
query, <code>and not</code> query, with diacritics as written in
the query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query will not return a result the user wants
because that result also includes what the user does not want,
"book drafts".</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content[. ftcontains 
   (("résumés" diacritics sensitive) ftor "drafts" 
   ftor "correspondence") ftand ftnot "book drafts"]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(./content ftcontains (("résumés" 
diacritics sensitive) ftor "drafts" ftor "correspondence") 
ftand ftnot "book drafts")&gt;0]
</pre></div>
<p><em>Expected Result: No results returned.</em></p>
</div>
<div class="div3">
<h4><a name="logical-queries-results-q7" id=
"logical-queries-results-q7"></a>10.2.7 Q7 Mild Not Query Where
Second Operand Is a Subset of the First Operand</h4>
<p>Find all books with listings for "résumés", "drafts", or
"correspondence", and not "book drafts", in the metadata or
text.</p>
<p>This query finds books with multiple words and not a phrase
which contains one of the words, while not eliminating a result if
it contains the phrase as well as one of the words searched.</p>
<ul>
<li>
<p>Operands: "résumés" "drafts" "correspondence" "book drafts"</p>
</li>
<li>
<p>Functionality: word queries, <code>or</code> query, phrase
query, <code>mild not</code> query, with diacritics as written in
the query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query will return a result the user wants even
though it contains the phrase the user deprecated via the mild not,
"book drafts". The user will not lose results which contain what he
wants when that book also contains what he does not want. Books
containing instances of "book drafts" (a subset of "drafts") are
not excluded, merely not considered.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains 
   (("résumés" diacritics sensitive) ftor "drafts" 
   ftor "correspondence") not in "book drafts"]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains (("résumés" 
diacritics sensitive) ftor "drafts" ftor "correspondence") 
not in "book drafts")&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt; 
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of software 
         applications and usability specialist. The collection 
         consists of <span class=
"found">correspondence</span>, memoranda, journals, 
         speeches, article <span class=
"found">drafts</span>, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, <span class=
"found">résumés</span> and other materials.&lt;/p&gt;
         &lt;/introduction&gt;
      ...      
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Cardinality" id="Cardinality"></a>11 Use Case
"CARDINALITY": Queries in Same, Any, Every Instance of an Element,
and Occurrence Count Query</h2>
<div class="div2">
<h3><a name="cardinality-description" id=
"cardinality-description"></a>11.1 Description</h3>
<p>These use cases illustrate instance queries and occurrence count
queries. They query words within the same, any, and every instance
of an element. Another query finds a phrase only if it occurs over
a specified number of times in a book.</p>
</div>
<div class="div2">
<h3><a name="cardinality-queries-results" id=
"cardinality-queries-results"></a>11.2 Queries and Results</h3>
<div class="div3">
<h4><a name="cardinality-queries-results-q1" id=
"cardinality-queries-results-q1"></a>11.2.1 Q1 Query in Same
Instance of an Element</h4>
<p>Find all books with the phrase "web site" and the word
"usability" in the same subject.</p>
<p>This query finds a word and a phrase in the same instance of an
element.</p>
<ul>
<li>
<p>Operands: "web site" "usability"</p>
</li>
<li>
<p>Functionality: phrase query, word query, <code>and</code>
query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/subjects/subject</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query finds a word and a phrase in an instance of
an element, not allowing one of the operands to be found in an
instance of the element and the other operand in a different
instance of the element. This query does not find Book 2 which has
"usability" and "web site" in different instances of the
<code>subject</code> element.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $subj := $book/metadata/subjects/subject[. ftcontains 
   "web site" ftand "usability"]
where count($subj)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(./metadata/subjects/subject ftcontains 
"web site" ftand "usability")&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...  
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;Usability testing&lt;/subject&gt;
         &lt;subject&gt;Web site development&lt;/subject&gt;        
         &lt;subject&gt;Heuristic evaluation&lt;/subject&gt;
         &lt;subject&gt;Cognitive walk-through&lt;/subject&gt;
         &lt;subject&gt;<span class=
"found">Web site</span> <span class=
"found">usability</span>&lt;/subject&gt;
      &lt;/subjects&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="cardinality-queries-results-q2" id=
"cardinality-queries-results-q2"></a>11.2.2 Q2 Query in Any
Instance of an Element (Existential Quantification)</h4>
<p>Find all books with the phrase "web site" and the word
"usability" in any subject.</p>
<p>This query finds a word and a phrase in any instance of an
element across the siblings of the same element. The word and the
phrase may be in different elements.</p>
<ul>
<li>
<p>Operands: "web site" "usability"</p>
</li>
<li>
<p>Functionality: phrase query, word query, <code>and</code> query,
existential quantification</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/subjects/subject</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query returns words and phrases in any instance
of an element, allowing one of the operands to be found in one
sibling and the other operand in a different sibling of the same
element name.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book                        
let $subj := $book/metadata/subjects/subject            
where (some $s1 in $subj satisfies $subj ftcontains "web site")    
   and (some $s2 in $subj satisfies $subj ftcontains "usability")
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book(some $s1 in ./metadata/subjects/subject satisfies 
./metadata/subjects/subject ftcontains "web site") 
and (some $s2  in ./metadata/subjects/subject satisfies 
./metadata/subjects/subject ftcontains "usability")
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...  
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;<span class=
"found">Usability</span> testing&lt;/subject&gt;
         &lt;subject&gt;<span class=
"found">Web site</span> development&lt;/subject&gt;          
         &lt;subject&gt;Heuristic evaluation&lt;/subject&gt;
         &lt;subject&gt;Cognitive walk-through&lt;/subject&gt;
         &lt;subject&gt;<span class=
"found">Web site</span> <span class=
"found">usability</span>&lt;/subject&gt;
      &lt;/subjects&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
   
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...  
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;<span class=
"found">Usability</span> testing&lt;/subject&gt;
         &lt;subject&gt;<span class=
"found">Web site</span> development&lt;/subject&gt;
         &lt;subject&gt;Guides and finding aids&lt;/subject&gt;
      &lt;/subjects&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="cardinality-queries-results-q3" id=
"cardinality-queries-results-q3"></a>11.2.3 Q3 Query in Every
Instance of an Element (Universal Quantification)</h4>
<p>Find all books with the words "ersatz" and "publications" in
every publisher name.</p>
<p>This query finds two words in every instance of an element.</p>
<ul>
<li>
<p>Operands: "ersatz" "publications"</p>
</li>
<li>
<p>Functionality: word query, <code>and</code> query, universal
quantification</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/publicationInfo/publisher</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query does not return a book if at least one of
its publishers does not contain the words "ersatz" and
"publications". Book 1 is returned because it has an instance of
the <code>publisher</code> element which satisfies the full-text
conditions (contains both "Ersatz" and "Publications"). Book 2 is
not returned because even though it has a publisher that satisfies
the full-text conditions, it also has a publisher that does not
satisfy it. Book 3 is not returned because it has an instance of
the <code>publisher</code> element which does not satisfy the query
(contains "Ersatz" but not "Publications").</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
where every $pub in $book//publisher satisfies 
   ($pub ftcontains "ersatz" ftand "publications")
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book(every $pub in .//publisher 
satisfies ($pub ftcontains "ersatz" ftand "publications"))
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
      &lt;publicationInfo&gt;   
         &lt;publisher&gt;<span class=
"found">Ersatz Publications</span>&lt;/publisher&gt;
      &lt;/publicationInfo&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="cardinality-queries-results-q4" id=
"cardinality-queries-results-q4"></a>11.2.4 Q4 Occurrence Count
Query</h4>
<p>Find all books which repeat the phrase "expert review methods"
in the text at least two times.</p>
<p>This query finds a phrase which is repeated a specified number
of times.</p>
<ul>
<li>
<p>Operands: "expert review methods"</p>
</li>
<li>
<p>Functionality: phrase query, at least functionality</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query excludes books with only minor (single
occurrence) references to "expert review methods".</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains 
   "expert review methods" occurs at least 2 times]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains "expert 
review methods" occurs at least 2 times)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;                                    
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         &lt;introduction&gt;
            ...
            &lt;p&gt;Two <span class=
"found">expert review methods</span> are discussed 
            here. They are heuristic evaluation and 
            cognitive walk-through.&lt;/p&gt; 
            &lt;p&gt;<span class=
"found">Expert review methods</span> should be 
            initiated early in the development process, 
            as soon as paper &lt;b&gt;p&lt;/b&gt;rototypes 
            (hand-drawn pictures of Web pages) or 
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are 
            available. They should be conducted using 
            the hardware and software similar to that 
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
         ...
      &lt;/part&gt;      
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Proximity" id="Proximity"></a>12 Use Case "PROXIMITY":
Queries on Proximity Relationships Including Distance, Window,
Sentence, and Paragraph</h2>
<div class="div2">
<h3><a name="proximity-description" id=
"proximity-description"></a>12.1 Description</h3>
<p>These use cases illustrate unordered and ordered distance
queries which find sequences of words allowing up to a specified
number of intervening words. They also include a query to find
words within a window, within a sentence, and within a
paragraph.</p>
</div>
<div class="div2">
<h3><a name="proximity-queries-results" id=
"proximity-queries-results"></a>12.2 Queries and Results</h3>
<div class="div3">
<h4><a name="proximity-queries-results-q1" id=
"proximity-queries-results-q1"></a>12.2.1 Q1 Unordered Distance
Query</h4>
<p>Find all books with information on "software developers".</p>
<p>This query finds multiple words in any order allowing up to a
specified number of intervening words.</p>
<ul>
<li>
<p>Operands: "software" "developer"</p>
</li>
<li>
<p>Functionality: word queries, stemming, unordered distance (0 to
3 intervening words)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query returns "developer of software", which
occurs in the sample data.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains 
   "software" ftand "developer" with stemming 
   distance at most 3 words]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains "software" 
ftand "developer" with stemming distance at most 3 words)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt; 
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a <span class=
"found">developer</span> of <span class="found">software</span> 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      ...      
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="proximity-queries-results-q2" id=
"proximity-queries-results-q2"></a>12.2.2 Q2 Ordered Distance
Query</h4>
<p>Find all books with information on "efficient task
completion".</p>
<p>This query finds multiple words in the order queried allowing up
to a specified number of intervening words.</p>
<ul>
<li>
<p>Operands: "efficient" "task" "completion"</p>
</li>
<li>
<p>Functionality: word queries, ordered distance (0 to 10
intervening words)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query is more permissive than an phrase query on
"efficient task completion" which would return no results.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains 
   "efficient" ftand "task" ftand "completion" 
   ordered distance at most 10 words]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains "efficient" 
ftand "task" ftand "completion" ordered
distance at most 10 words )&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         ... 
         &lt;p&gt;The usability of a Web site is how well the 
         site supports the user in achieving specified 
         goals. A Web site should facilitate learning, 
         and enable <span class=
"found">efficient</span> and effective <span class=
"found">task</span>
         <span class=
"found">completion</span>, while propagating few errors.
         Satisfaction with the site is also important. 
         The user must not only be well-served, but must 
         feel well-served.&lt;/p&gt; 
         ...
      &lt;/introduction&gt;
      ...   
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="proximity-queries-results-q3" id=
"proximity-queries-results-q3"></a>12.2.3 Q3 Ordered Window
Query</h4>
<p>Find all books about "users feeling well-served".</p>
<p>This query finds books with multiple words within an ordered
window of up to a specified number of words.</p>
<ul>
<li>
<p>Operands: "users" "feeling" "well served" "well-served"</p>
</li>
<li>
<p>Functionality: word queries, ordered window (0 to 15 words)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query opens a window on the first found word
(which must be the first word queried) and counts a specified
number of words from that first word within which it may find the
remaining word or words, finding them in the order queried.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains 
   "users" ftand "feeling" ftand ("well served" ftor "well-served")
   with stemming ordered window 15 words]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains "users" 
ftand "feeling" ftand ("well served" ftor "well-served") with stemming 
ordered window 15 words)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ... 
         &lt;p&gt;The usability of a Web site is how well the 
         site supports the user in achieving specified 
         goals. A Web site should facilitate learning, 
         and enable efficient and effective task
         completion, while propagating few errors.         
         Satisfaction with the site is also important. 
         The <span class=
"found">user</span> must not only be well-served, but must
         <span class="found">feel</span> <span class=
"found">well</span>-<span class="found">served</span>.&lt;/p&gt;  
         ...
      &lt;/introduction&gt;
      ...   
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="proximity-queries-results-q4" id=
"proximity-queries-results-q4"></a>12.2.4 Q4 Unordered Within a
Sentence Query</h4>
<p>Find all books which discuss "questions asked during cognitive
walk-throughs".</p>
<p>This query finds books with multiple words in any order within a
sentence.</p>
<ul>
<li>
<p>Operands: "users" "would" "know" "step"</p>
</li>
<li>
<p>Functionality: word queries, stemming, unordered sentence
query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query expects an implementation-defined tokenized
sentence or a <code>sentence</code> element.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains 
   "users" ftand "would" ftand "know" ftand "step" 
   with stemming same sentence]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains "users" ftand "would" 
ftand "know" ftand "step" with stemming same sentence)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;                                    
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;p&gt;Expert reviewers evaluate Web site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "<span class=
"found">Would</span> a
            <span class="found">user</span> <span class=
"found">know</span> by looking at the screen how to
            complete the first <span class=
"found">step</span> of the task?" and "If            
            the user completed the first step, would the 
            user know what to do next?," with the goal of 
            identifying any obstacles to completing the 
            task and assessing whether the user would 
            cognitively be aware that he was successful in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="proximity-queries-results-q5" id=
"proximity-queries-results-q5"></a>12.2.5 Q5 Unordered Within a
Paragraph Query</h4>
<p>Find all paragraphs which define what "Web site usability"
is.</p>
<p>This query finds books with multiple words and phrases in any
order within a paragraph.</p>
<ul>
<li>
<p>Operands: "usability" "web site" "efficiency" "satisfaction"</p>
</li>
<li>
<p>Functionality: word queries, phrase query, unordered paragraph
query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query expects an implementation-defined tokenized
paragraph or a <code>paragraph</code> element.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book//content[. ftcontains 
   "usability" ftand "web site" ftand "efficiency" 
   ftand "satisfaction" same paragraph]
where count($cont)&gt;0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains "usability" 
ftand "web site" ftand "efficiency" ftand "satisfaction" 
same paragraph)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         ... 
         &lt;p&gt;The <span class=
"found">usability</span> of a <span class=
"found">Web site</span> is how well the 
         site supports the user in achieving specified 
         goals. A <span class=
"found">Web site</span> should facilitate learning, 
         and enable <span class=
"found">efficient</span> and effective task
         completion, while propagating few errors.         
         <span class=
"found">Satisfaction</span> with the site is also important.. 
         The user must not only be well-served, but must
         feel well-served.&lt;/p&gt;  
         ...
      &lt;/introduction&gt;
      ...   
   &lt;/content&gt;                                     
&lt;/book&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Axes" id="Axes"></a>13 Use Case "AXES": Queries Using
Relative XPath Axes</h2>
<div class="div2">
<h3><a name="axes-description" id="axes-description"></a>13.1
Description</h3>
<p>These use cases illustrate queries traversing relative XPath
axes.</p>
</div>
<div class="div2">
<h3><a name="axes-queries-results" id=
"axes-queries-results"></a>13.2 Queries and Results</h3>
<div class="div3">
<h4><a name="axes-queries-results-q1" id=
"axes-queries-results-q1"></a>13.2.1 Q1 Query on Element and Its
Children</h4>
<p>Find all books with paragraphs containing the phrase "computer
workstation" and footnotes within those paragraphs containing the
word "comfortable".</p>
<p>This query finds a phrase in an element, then finds a word in a
child element.</p>
<ul>
<li>
<p>Operands: "computer workstation" "comfortable"</p>
</li>
<li>
<p>Functionality: phrase query, word query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .//p, .//p/footnote</p>
</li>
<li>
<p>Return: ./metadata/title, .//p</p>
</li>
<li>
<p>Comments: This query combines phrase and word search in
different elements which have a parent-child relationship.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $para := $book//p[. ftcontains "computer 
   workstation"]
let $fn := $para/footnote[. ftcontains "comfortable"]
where count($fn)&gt;0
return ($book/metadata/title, $para)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//p ftcontains "computer workstation" 
and .//p/footnote ftcontains "comfortable")&gt;0]/(metadata/title 
| .//p)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;      
&lt;p&gt;Users can be tested at any <span class=
"found">computer</span> 
<span class=
"found">workstation</span>&lt;footnote&gt;They may be more 
<span class=
"found">comfortable</span> at their own workstation than in 
 a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="axes-queries-results-q2" id=
"axes-queries-results-q2"></a>13.2.2 Q2 Query on Element Returning
Its First Two Children</h4>
<p>Find the first two steps in chapters on "conducting usability
tests."</p>
<p>This query finds words in an element, then returns its first two
children elements.</p>
<ul>
<li>
<p>Operands: "usability", "test"</p>
</li>
<li>
<p>Functionality: word queries, stemming</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/part/chapter/p</p>
</li>
<li>
<p>Return: ./metadata/title ./content/part/chapter/p/step[1],
./content/part/chapter/p/step[2]</p>
</li>
<li>
<p>Comments: This query finds words in a <code>p</code> element and
uses XPath to return the first two children of the element.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $para := $book[.//chapter/p ftcontains "usability" 
   ftand "test" with stemming]
where count($para) &gt; 0   
return ($book/metadata/title, $para/step[1], $para/step[2])
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book//chapter/p[count(. ftcontains "usability" 
ftand "test" with stemming)&gt;0]/(metadata/book 
| .//chapter/p/step[1] | .//chapter/p/step[2])
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;   
&lt;step number="1"&gt;Clarify and articulate 
the goal of the usability testing.&lt;/step&gt; 
&lt;step number="2"&gt;Identify tasks which 
are critical for users to be able to complete 
successfully.&lt;/step&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="axes-queries-results-q3" id=
"axes-queries-results-q3"></a>13.2.3 Q3 Query on Element and Its
Ancestors</h4>
<p>Are there any "flow diagrams" of "human computer interaction"
scenarios in John Wesley Usabilityguy's papers?</p>
<p>This query finds a phrase in an element, then finds another
phrase in an ancestor element.</p>
<ul>
<li>
<p>Operands: "flow diagrams" "human computer interaction"</p>
</li>
<li>
<p>Functionality: phrase queries, character wildcard (suffix) (0 or
one)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book[@number="3"]</p>
</li>
<li>
<p>Query context:
./content/part/component/subcomponent/componentTitle,
./content/part/component/subcomponent/subsubcomponent/componentTitle</p>
</li>
<li>
<p>Return: ./metadata/title, ./content</p>
</li>
<li>
<p>Comments: This query looks for a phrase in an element and a
different phrase in its ancestor elements.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[@number="3"]
let $comp := $book[./content/part/component/
   (subcomponent | subcomponent/subsubcomponent)/
   componentTitle ftcontains "flow diagram.?" 
   with wildcards]
let $parentComp := $book[ancestor::books//../$comp 
  ftcontains "human computer interaction"]
where count($comp) &gt; 0   
return ($book/metadata/title, $book/content)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[@number="3" and count((./content/part/
component(subcomponent | subcomponent/subsubcomponent) 
ftcontains "flow diagram.?" with wildcards 
and ancestor::books//(subcomponent | subcomponent/
subsubcomponent) ftcontains "human computer 
interaction"))&gt;0]/(metadata/title | ./content)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Usabilityguy Manuscript 
Guide"&gt;John Wesley Usabilityguy: A Register of His 
Papers&lt;/title&gt;
&lt;content&gt;
   ...
   &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
      &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
      1930-1974&lt;/date&gt;&lt;/title&gt;
        ...
        &lt;subComponent&gt;
           &lt;componentTitle&gt;<span class=
"found">Human Computer Interaction</span> 
           research, &lt;componentDate normalize="1945/1952"&gt;
           1945-1952&lt;/componentDate&gt;
           &lt;/componentTitle&gt;
           &lt;subsubComponent&gt;
              &lt;componentTitle&gt;<span class=
"found">Flow diagram</span>, 
              &lt;componentDate normalize="1950"&gt;1950
              &lt;/componentDate&gt;
              &lt;/componentTitle&gt;
           &lt;/subsubComponent&gt;
           ...
         &lt;/subComponent&gt;
      &lt;/component&gt;
   &lt;/part&gt;
&lt;/content&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="axes-queries-results-q4" id=
"axes-queries-results-q4"></a>13.2.4 Q4 Query on Element and Its
Right Siblings</h4>
<p>Find all book chapters with paragraphs on "usability testing"
followed by paragraphs on "information architecture".</p>
<p>This query finds a phrase in an element, then finds another
phrase in one of its right siblings.</p>
<ul>
<li>
<p>Operands: "usability testing" "information architecture"</p>
</li>
<li>
<p>Functionality: phrase queries</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/part/chapter/p</p>
</li>
<li>
<p>Return: ./metadata/title, .//content</p>
</li>
<li>
<p>Comments: This query returns book chapters if they contain
paragraphs following each other as specified in the query.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $chapters := $book//chapter[./p ftcontains "usability 
   testing" and ./p/following-sibling::p ftcontains 
   "information architecture"]
where count($chapters)&gt;0
return ($book/metadata/title, $chapters)
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
        &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...      
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some tests of the site with your unique 
            audience or audiences by conducting <span class=
"found">usability</span>
            <span class="found">testing</span>.&lt;/p&gt;
            &lt;p&gt;Users are asked to complete tasks which 
            measure the success of the <span class=
"found">information</span> 
            <span class=
"found">architecture</span> and navigational elements of the 
            site.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Ignore" id="Ignore"></a>14 Use Case "IGNORE": Queries
Ignoring Descendant Element Content</h2>
<div class="div2">
<h3><a name="ignore-description" id="ignore-description"></a>14.1
Description</h3>
<p>These phrase and proximity queries cross element boundaries
ignoring the content of descendant elements. One query ignores the
content of a complete sub-tree. Other queries ignore only the
content of specified descendant elements. The last query performs a
level-by-level ignore. It ignores the content of descendant
elements when querying the content of the parent element. Its
descendant elements are promoted and then their content is
queried.</p>
</div>
<div class="div2">
<h3><a name="ignore-queries-results" id=
"ignore-queries-results"></a>14.2 Queries and Results</h3>
<div class="div3">
<h4><a name="ignore-queries-results-q1" id=
"ignore-queries-results-q1"></a>14.2.1 Q1 Distance Query Ignoring
Content of All Descendant Elements</h4>
<p>Find advice on whether the observer should "correct" or provide
"guidance" to the user during usability "testing".</p>
<p>This query ignores the content of all descendant elements.</p>
<ul>
<li>
<p>Operands: "testing" "correct" "guidance"</p>
</li>
<li>
<p>Functionality: phrase query, word queries, <code>or</code>
query, ordered distance query (0 to 60 intervening words), ignore
content of descendant elements</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .//p</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query ignores the content of all the descendant
elements of the <code>p</code> element, so it ignores the
<code>footnote</code> and <code>testingProcedure</code> elements.
If the descendant elements were not ignored, the words searched
would be too distant from each other to have been returned.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $p := $book//p [. ftcontains "testing" 
   ftand ("guidance" ftor "correct") distance at 
   most 60 words without content *] 
where count($p) &gt; 0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books//p[count(. ftcontains "testing" 
ftand ("guidance" ftor "correct") distance at 
most 60 words without content *)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...                                       
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            ...
            &lt;p&gt;Give the user the script, then assure them 
            that you are <span class=
"found">testing</span> the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;Usability 
            testing can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no <span class=
"found">guidance</span> or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         ...
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="ignore-queries-results-q2" id=
"ignore-queries-results-q2"></a>14.2.2 Q2 Phrase Query Ignoring
Content of Descendant Element Specified by XPath Expression</h4>
<p>Find all book chapters containing "users can be tested at any
computer workstation or in a lab" ignoring footnotes.</p>
<p>This query finds book chapters containing the phrase "users can
be tested at any computer workstation or in a lab" ignoring the
content of a descendant element explicitly specified by an XPath
expression.</p>
<ul>
<li>
<p>Operands: "users can be tested at any computer workstation or in
a lab"</p>
</li>
<li>
<p>Functionality: phrase query, ignore content of
<code>footnote</code> element</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/part/chapter</p>
</li>
<li>
<p>Return: ./metadata/title, ./content/part/chapter</p>
</li>
<li>
<p>Comments: This query ignores the content of a descendant
element, the <code>footnote</code> element.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $chap := $book//chapter[. ftcontains 
   "users can be tested at any computer workstation 
   or in a lab" without content .//footnote] 
where count($chap) &gt; 0
return ($book/metadata/title, $chap)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//chapter ftcontains "users can be 
tested at any computer workstation or in a lab" 
without content .//footnote)&gt;0]/(metadata/title | .//chapter)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;
&lt;chapter&gt;
   ...
   &lt;p&gt;<span class=
"found">Users can be tested at any computer</span>  
   <span class=
"found">workstation</span> &lt;footnote&gt;They may be more 
   comfortable at their own workstation than in 
   a lab.&lt;/footnote&gt;<span class=
"found">or in a lab</span>.&lt;/p&gt; 
   ...
&lt;/chapter&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="ignore-queries-results-q3" id=
"ignore-queries-results-q3"></a>14.2.3 Q3 Phrase Query Ignoring
Content of Descendant Element Specified by Full-Text Query</h4>
<p>Find all book chapters containing the phrase "at any computer
workstation or in a lab" ignoring footnotes on workstations.</p>
<p>This query ignores the content of a descendant element specified
by a full-text query.</p>
<ul>
<li>
<p>Operands: "at any computer workstation or in a lab",
"workstations"</p>
</li>
<li>
<p>Functionality: phrase query, character wildcard (suffix) (1),
ignore content of a descendant element found by a full-text
query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/part/chapter</p>
</li>
<li>
<p>Return: ./metadata/title, ./content/part/chapter</p>
</li>
<li>
<p>Comments: This query ignores the content of a descendant element
identified dynamically by a full-text query.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $chap := $book//chapter[. ftcontains 
   "at any computer workstation or in a lab" 
   without content (.//footnote[. ftcontains 
   "workstation." with wildcards])]
where count($chap) &gt; 0
return ($book/metadata/title, $chap)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//chapter ftcontains "at any computer 
workstation or in a lab" without content 
.//footnote[. ftcontains "workstation." with wildcards])&gt;0]
/metadata/title | .//chapter
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your Web 
Site&lt;/title&gt;
&lt;chapter&gt;
   ...
   &lt;p&gt;Users can be tested <span class=
"found">at any computer</span>
   <span class=
"found">workstation</span>&lt;footnote&gt;They may be more
   comfortable at their own workstation than in 
   a lab.&lt;/footnote&gt;<span class=
"found">or in a lab</span>.&lt;/p&gt;   
   ...
&lt;/chapter&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="ignore-queries-results-q4" id=
"ignore-queries-results-q4"></a>14.2.4 Q4 Distance Query Ignoring
Content of Descendant Elements Level by Level</h4>
<p>Find all books with the word "workstation" near the word
"lab".</p>
<p>This query performs a level-by-level ignore. It ignores the
content of descendant elements when querying the content of the
parent element. Its descendant elements are promoted and then their
content is queried. It differs from the ignore queries above
because it queries the content of parent elements skipping over the
descendant elements, then instead of stopping there it queries the
content of descendent elements in isolation.</p>
<ul>
<li>
<p>Operands: "workstation" "lab"</p>
</li>
<li>
<p>Functionality: word queries, unordered distance (0 to 6
intervening words), level by level ignore (ignore the content of
descendant element when searching the parent element and promote
the descendant element and query it in isolation)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/part/chapter/p,
/content/part/chapter/p/footnote</p>
</li>
<li>
<p>Return: ./metadata/title, $where,</p>
</li>
<li>
<p>Comments: This query ignores the content of the descendant
element <code>footnote</code> when querying its parent element
<code>p</code> returning "workstation" and "lab" from "Users can be
tested at any computer workstation or in a lab". Then the
descendant element <code>footnote</code> is promoted and queried
separately returning "workstation" and "lab" from "They may be more
comfortable at their own workstation than in a lab". This query is
written using the standard ignore syntax ORing together parent and
descendant elements to be queried separately.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $where := ($book//chapter/p | $book//chapter/p/footnote) 
   [. ftcontains "workstation" ftand "lab" 
   distance at most 6 words without content ./footnote]
where fn:count($where) &gt; 0
return ($book/metadata/title, $where)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book/chapter[count((./p | ./p/footnote) 
ftcontains "workstation" ftand "lab" distance at most 6 words 
without content ./footnote)&gt;0]/(metadata/title | ./p 
| ./p/footnote)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Usability Basics"&gt;Usability 
   Basics: How to Plan for and Conduct Usability Tests 
   on Web Site Thereby Improving the Usability of Your 
   Web Site&lt;/title&gt;
&lt;p&gt;Users can be tested at any computer 
   <span class=
"found">workstation</span> &lt;footnote&gt;They may be more 
   comfortable at their own workstation than in 
   a lab.&lt;/footnote&gt; or in a <span class=
"found">lab</span>.&lt;/p&gt;
&lt;footnote&gt;They may be more comfortable at their own 
   <span class="found">workstation</span> than in a <span class=
"found">lab</span>.&lt;/footnote&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Full-Text-Composability" id=
"Full-Text-Composability"></a>15 Use Case
"FULL-TEXT-COMPOSABILITY": Queries Illustrating Composability of
Full-Text with Itself</h2>
<div class="div2">
<h3><a name="full-text-composability-description" id=
"full-text-composability-description"></a>15.1 Description</h3>
<p>The use cases illustrate a multi-lingual query and queries which
use multiple full-text functionalities in conjunction with other
XQuery and XPath functionalities.</p>
</div>
<div class="div2">
<h3><a name="full-text-composability-queries-results" id=
"full-text-composability-queries-results"></a>15.2 Queries and
Results</h3>
<div class="div3">
<h4><a name="full-text-composability-queries-results-q1" id=
"full-text-composability-queries-results-q1"></a>15.2.1 Q1 Query on
Words and Phrases in Two Languages</h4>
<p>Find all books with the subject "网站可用性", with an introduction
written by "Elina Rose", which mention the name of the usability
expert "Millicent Marigold".</p>
<p>This query finds words and a phrase in more than one
language.</p>
<ul>
<li>
<p>Operands: "网站可用性" "Elina" "Rose" "Millicent" "Marigold"</p>
</li>
<li>
<p>Functionality: phrase query, word queries, <code>and</code>
query, unordered distance (0 to 3 intervening words), capacity to
enter, query, and return multiple languages</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/subjects/subject,
./content/introduction/author, ./content</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title,
./metadata/subjects/subject, ./content/introduction/author,
./content</p>
</li>
<li>
<p>Comments: This query accepts multiple languages as input and
returns multiple languages as output.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
where $book//subject[. ftcontains "网站可用性" language "zh"]
   and $book/content/introduction/author[. ftcontains 
   "Elina" ftand "Rose" distance at most 3 words]
   and $book//content[. ftcontains "Millicent" ftand "Marigold" 
   distance at most 3 words]
return &lt;book number="{$book/@number}"&gt; 
          {$book/metadata/title, $book//subject, 
          $book/content/introduction, $book//content} 
       &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the Usability of a Web Site Through Expert Reviews 
   and Usability Testing&lt;/title&gt;
   &lt;subject&gt;<span class="found">网站可用性</span>&lt;/subject&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;author&gt;<span class=
"found">Elina</span> <span class="found">Rose</span>&lt;/author&gt;
         ...   
         &lt;p&gt;The most successful projects employ multiple methods 
         in multiple iterations. As <span class=
"found">Millicent</span> <span class=
"found">Marigold</span> remarked 
         during a recent conference, "Don't stop. Iterate, iterate, 
         then iterate again."&lt;/p&gt;
         ...
      &lt;/introduction&gt;   
      ...      
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="full-text-composability-queries-results-q2" id=
"full-text-composability-queries-results-q2"></a>15.2.2 Q2 Phrase
and Distance Query in an Instance of an Element with Stemming</h4>
<p>Find all paragraphs in books which discuss the role of "task
performance" in "expert review methods".</p>
<p>This query finds multiple words close to each other and a phrase
in one instance of an element.</p>
<ul>
<li>
<p>Operands: "task" "performance" "expert review"</p>
</li>
<li>
<p>Functionality: word queries, stemming, phrase query, unordered
distance (0 to 3 intervening words between "task" and
"performance")</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content//p</p>
</li>
<li>
<p>Return: ./metadata/title, ./content//p</p>
</li>
<li>
<p>Comments: This query combines functionalities introduced in
previous sections.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $para := $book/content//p[. ftcontains 
   ("task" ftand "performance" with stemming distance 
   at most 3 words) ftand "expert review" with stemming]
where count($para) &gt; 0
return ($book/metadata/title, $book//content)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content/p ftcontains ("task" 
ftand "performance" with stemming distance 
at most 3 words) ftand "expert review" with stemming)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the Usability of a Web Site Through Expert Reviews and 
   Usability Testing&lt;/title&gt;
&lt;content&gt;
   ...   
   &lt;part number="1"&gt;
      &lt;title&gt;Expert Reviews&lt;/title&gt;
      ...
      &lt;chapter&gt;
         &lt;title&gt;Cognitive Walk-Through&lt;/title&gt;
         &lt;p&gt;<span class=
"found">Expert reviewers</span> evaluate Web site 
         understandability and ease of learning while 
         <span class=
"found">performing</span> specified <span class=
"found">tasks</span>. They walk through 
         the site answering questions such as "Would a 
         user know by looking at the screen how to 
         complete the first step of the task?" and "If 
         the user completed the first step, would the 
         user know what to do next?," with the goal of 
         identifying any obstacles to completing the 
         task and assessing whether the user would 
         cognitively be aware that he was successful in 
         completing a step in the process.&lt;/p&gt;
      &lt;/chapter&gt;
   &lt;/part&gt;
   ...   
&lt;/content&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="full-text-composability-queries-results-q3" id=
"full-text-composability-queries-results-q3"></a>15.2.3 Q3 Nested
Distance Query with Wildcards, Stemming, and Thesaurus Support</h4>
<p>Find all books on "usability testing" which "quote" "Millicent
Marigold" on the value of multiple "iterations".</p>
<p>This query finds multiple words in three nested levels of
distance queries. It uses wildcards, stemming, and thesaurus
support.</p>
<ul>
<li>
<p>Operands: "usability testing" "quote" "millicent" "marigold"
"iterations"</p>
</li>
<li>
<p>Functionality: phrase query, character wildcard (suffix) (0-5),
word queries, thesaurus support, stemming, ordered distance (0 to 3
intervening words between "millicent" and "marigold"), unordered
distance (0 to 3 intervening words between ("millicent ...
marigold" and (one of the following from stemming: "quote",
"quoted", "quotes", "quotation", "quotations" or one of the
following from thesaurus support: "said", "says", "stated",
"states", "statement", "spoke", "speaks", "replied', "replies",
"reply", "remarks", "remarked", "responded", "response", "reports
", "reported", "quotes", "quoted", "according", "commented",
"discussed", "expressed", "told"), unordered distance (0 to 50
intervening words between ("millicent ... marigold" ... ("quote" or
any of its wildcard- or thesaurus-derived substitutes) and
("usability testing" and "iterations")).</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query combines functionalities introduced in
previous sections.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $quote := $book//content[. ftcontains (("millicent" 
   ftand "marigold" ordered distance at most 3 words)
   ftand "quote.{0-5}" with wildcards with thesaurus at  
   "http://bstore1.example.com/UsabilityThesaurus.xml"
   relationship "synonyms" distance at most 3 words) 
   ftand "usability testing" ftand "iterations" with stemming 
   distance at most 50 words]
where count($quote) &gt; 0
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(.//content ftcontains (("millicent" 
ftand "marigold" ordered distance at most 3 words)
ftand "quote.{0-5}" with wildcards with thesaurus at 
"http://bstore1.example.com/UsabilityThesaurus.xml"
relationship "synonyms" distance at most 3 words) 
ftand "usability testing" ftand "iterations" with stemming 
distance at most 50 words)&gt;0]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ...   
         &lt;p&gt;Expert reviews and <span class=
"found">usability testing</span> are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate 
         users and drive them away from your site.&lt;/p&gt;      
         &lt;p&gt;The most successful projects employ multiple 
         methods in multiple iterations. As <span class=
"found">Millicent</span>
         <span class="found">Marigold</span> <span class=
"found">remarked</span> during a recent conference, 
         "Don't stop. <span class=
"found">Iterate</span>, <span class=
"found">iterate</span>, then <span class=
"found">iterate</span>          
         again."&lt;/p&gt;
      &lt;/introduction&gt;
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="full-text-composability-queries-results-q4" id=
"full-text-composability-queries-results-q4"></a>15.2.4 Q4 Window
Query with Wildcards and Stemming Ignoring Content of a Descendant
Element</h4>
<p>Find advice on whether an observer in a "usability test" should
"correct" or provide "guidance" to the user in a book not authored
by Montana Marigold.</p>
<p>This query uses synonyms supplied by the user, uses the unary
not, nests a Boolean query and a phrase query within a window
query, and ignores the tags and content of a descendant
element.</p>
<ul>
<li>
<p>Operands: "usability testing" "correct" "comment" "guidance"
"help" "assistance" "montana" "marigold"</p>
</li>
<li>
<p>Functionality: phrase query, word queries, character wildcard
(suffix) (0 or more), synonyms for "correct" and "guidance"
provided by the user ("comment" or "assistance" or "help"),
stemming, <code>or</code> query ("correct" or "comment" or
"guidance" or "assistance" or "help"), <code>and</code> query
("montana" and "marigold"), <code>unary not</code> query (not
"montana" and "marigold"), unordered window (0 to 70 words within a
window of "usability testing" and ("correct" or "comment" or
"guidance" or "assistance" or "help"). Ignores content of
descendant elements.</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/author, ./content</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, ./content</p>
</li>
<li>
<p>Comments: This query combines functionalities introduced in
previous sections.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $au := $book/metadata/author[. ftcontains ftnot ("montana" 
  ftand "marigold")]   
let $co := $book//content[. ftcontains (("correct" 
   ftor ("comment" with stemming) ftor "guidance" ftor "assistance" 
   ftor "help") ftand "usability test.*" with wildcards) 
   window 70 words without content .//footnote]
where count($au) &gt; 0 and  count($co) &gt; 0 
return &lt;book number="{$book/@number}"&gt; 
          {$book/metadata/title,
          $book//content}
       &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;Usability 
   Basics: How to Plan for and Conduct Usability Tests 
   on Web Site Thereby Improving the Usability of Your 
   Web Site&lt;/title&gt;
   &lt;content&gt;
      ...                                       
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting <span class=
"found">Usability Tests</span>&lt;/title&gt; 
            &lt;p&gt;Users can be tested at any computer 
            workstation &lt;footnote&gt;They may be more 
            comfortable at their own workstation than in 
            a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;Usability 
            testing can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no <span class=
"found">guidance</span> or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         ...
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="full-text-composability-queries-results-q5" id=
"full-text-composability-queries-results-q5"></a>15.2.5 Q5 Query on
Different Elements in Different Sub-Trees with Conditional
Return</h4>
<p>For each book with a title containing the word "usability", a
book introduction containing the word "satisfaction", and a part
introduction containing the phrase "identify problems", return the
book title and the authors if it has authors. Return the book title
and publisher, if it has no authors. Always return the content
surrounding the found words.</p>
<p>This query finds words and a phrase in different elements in
different sub-trees. It also contains a conditional return.</p>
<ul>
<li>
<p>Operands: "usability" "satisfaction" "identify problems"</p>
</li>
<li>
<p>Functionality: word queries, phrase query, conditional query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title, ./content/introduction,
./content/part/introduction</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, ./metadata/author,
./metadata/publicationInfo/publisher, ./content/introduction,
./content/part/introduction</p>
</li>
<li>
<p>Comments: This query combines functionalities introduced in
previous sections.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $title := $book/metadata/title[. ftcontains 
   "usability"]
let $in := $book/content/introduction[. ftcontains 
   "satisfaction"]
let $pin := $book/content/part/introduction[. ftcontains 
   "identify problems"]
where count($title)&gt;0 and count($in)&gt;0 
   and count($pin)&gt;0
return &lt;book number="{$book/@number}"&gt; 
          {$title} 
          if (count($book/metadata/author) &gt; 0)
          then {$book/metadata/author, $in, $pin}
          else {$book/metadata/publicationInfo/publisher, $in, $pin}
       &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
   and <span class=
"found">Usability</span> Testing&lt;/title&gt;     
   &lt;author&gt;Millicent Marigold&lt;/author&gt;  
   &lt;author&gt;Montana Marigold&lt;/author&gt;     
   &lt;introduction&gt;
      ...
      &lt;p&gt;The usability of a Web site is how well the 
      site supports the user in achieving specified 
      goals. A Web site should facilitate learning, 
      and enable efficient and effective task 
      completion, while propagating few 
      errors. <span class=
"found">Satisfaction</span> with the site is also important. 
      The user must not only be well-served, but must 
      feel well-served.&lt;/p&gt;
      ...
  &lt;/introduction&gt;
  &lt;introduction&gt;
      &lt;p&gt;Expert reviewers <span class=
"found">identify problems</span> and recommend changes 
      to web sites based on research in human computer interaction 
      and their experience in the field.&lt;/p&gt;
      ...
  &lt;/introduction&gt; 
&lt;/book&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="XQuery-XPath-Composability" id=
"XQuery-XPath-Composability"></a>16 Use Case
"XQUERY-XPATH-COMPOSABILITY": Queries Illustrating Composability of
Full-Text with Other XQuery and XPath Functionalities</h2>
<div class="div2">
<h3><a name="xquery-xpath-composability-description" id=
"xquery-xpath-composability-description"></a>16.1 Description</h3>
<p>These queries combine full-text queries with other XQuery and
XPath functionalities.</p>
</div>
<div class="div2">
<h3><a name="xquery-xpath-composability-queries-results" id=
"xquery-xpath-composability-queries-results"></a>16.2 Queries and
Results</h3>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q1" id=
"xquery-xpath-composability-queries-results-q1"></a>16.2.1 Q1
Full-Text Query Constructing New Element</h4>
<p>For books with "usability" in the title create a flat list of
all title-author pairs, with each pair enclosed in a newly
constructed element.</p>
<p>This query finds a word in an element and returns the element
and another wrapped in a new element.</p>
<ul>
<li>
<p>Operands: "usability"</p>
</li>
<li>
<p>Functionality: word query, construction of new element</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title</p>
</li>
<li>
<p>Return: result (constructed element), ./metadata/title,
./metadata/author</p>
</li>
<li>
<p>Comments: This query finds the word "usability" in the title of
a book and building title-author pairs for those books returning
them wrapped in a newly constructed result element.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $var := $book[./metadata/title ftcontains "usability"]
where count ($var) &gt; 0   
return &lt;result&gt; 
          {$book/metadata/title, $book/metadata/author} 
       &lt;/result&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;result&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
   and <span class="found">Usability</span> Testing&lt;/title&gt;
   &lt;author&gt;Millicent Marigold&lt;/author&gt;
   &lt;author&gt;Montana Marigold&lt;/author&gt;
&lt;/result&gt;
   
&lt;result&gt;
   &lt;title shortTitle="Usability Basics"&gt;<span class=
"found">Usability</span> 
   Basics: How to Plan for and Conduct <span class=
"found">Usability</span> Tests 
   on Web Site Thereby Improving the <span class=
"found">Usability</span> of Your 
   Web Site&lt;/title&gt;
&lt;/result&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q2" id=
"xquery-xpath-composability-queries-results-q2"></a>16.2.2 Q2
Full-Text Query Returning Count of Descendant Element
Occurrences</h4>
<p>Find all books with a chapter title on "usability tests". Return
book title, chapter title, and the number of steps in chapters.</p>
<p>This query finds words then returns among other elements a
constructed element reporting the number of occurrences of a
descendant element.</p>
<ul>
<li>
<p>Operands: "usability" "test"</p>
</li>
<li>
<p>Functionality: word queries, <code>and</code> query, stemming,
count(), construction of new element</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/part/chapter/title,
./content/part/chapter/p/step</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title,
./content/part/chapter/title, number-of-steps (constructed
element)</p>
</li>
<li>
<p>Comments: This query finds the word "usability" and stemmed
forms of the word "test" in the titles of book chapters. It returns
chapter titles along with an occurrence count of descendant
<code>step</code> elements. The query returns a number of steps
equal to 0 if the chapter is on usability testing but does not
specify any steps (e.g., there are not descendant <code>step</code>
elements).</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $ct := $book/content/part/chapter/title[. ftcontains 
   "usability" ftand ("test" with stemming)]
where count($ct)&gt;0
return &lt;book number="{$book/@number}"&gt; 
          {$book/metadata/title,
          for $title in $ct
          return 
             ($title, 
             &lt;number-of-steps&gt; 
                {count($title/..//step)}
             &lt;/number-of-steps&gt;)}
       &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the Usability of a Web Site Through Expert Reviews and 
   Usability Testing&lt;/title&gt;
   &lt;title&gt;<span class=
"found">Usability Testing</span>&lt;/title&gt;
   &lt;number-of-steps&gt;0&lt;/number-of-steps&gt;
 &lt;/book&gt;

&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;Usability 
   Basics: How to Plan for and Conduct Usability Tests 
   on Web Site Thereby Improving the Usability of Your 
   Web Site&lt;/title&gt;
   &lt;title&gt;Planning then Conducting <span class=
"found">Usability</span>
   <span class="found">Tests</span>&lt;/title&gt;
   &lt;number-of-steps&gt;7&lt;/number-of-steps&gt;
   &lt;title&gt;Conducting <span class=
"found">Usability Tests</span>&lt;/title&gt;
   &lt;number-of-steps&gt;0&lt;/number-of-steps&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q3" id=
"xquery-xpath-composability-queries-results-q3"></a>16.2.3 Q3
Full-Text Query with Conditional Return</h4>
<p>For each book with "usability" in the book title, return the
book title and a second element. Return the book title and a third
element if the second element does not exist.</p>
<p>This query finds a word and contains a conditional return.</p>
<ul>
<li>
<p>Operands: "usability"</p>
</li>
<li>
<p>Functionality: word query, conditional expression</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, ./metadata/author,
./metadata/publicationInfo/publisher</p>
</li>
<li>
<p>Comments: This query finds the word "usability" in the title of
a book, then returns title-author pairs for those books when there
are <code>author</code> elements. If there are no
<code>author</code> elements, it returns <code>publisher</code>
elements.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[./metadata/title ftcontains 
   "usability"]
return &lt;book number="{$book/@number}"&gt;
          {$book/metadata/title,
             if (count($book/metadata//author) &gt; 0) 
             then $book/metadata//author 
             else $book/metadata//publisher}
       &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
   and <span class="found">Usability</span> Testing&lt;/title&gt;
   &lt;author&gt;Millicent Marigold&lt;/author&gt;
   &lt;author&gt;Montana Marigold&lt;/author&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;<span class=
"found">Usability</span> 
   Basics: How to Plan for and Conduct <span class=
"found">Usability</span> Tests 
   on Web Site Thereby Improving the <span class=
"found">Usability</span> of Your 
   Web Site&lt;/title&gt;
   &lt;publisher&gt;Ersatz Publications&lt;/publisher&gt;
   &lt;publisher&gt;Electronic BookWorks&lt;/publisher&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q4" id=
"xquery-xpath-composability-queries-results-q4"></a>16.2.4 Q4
Full-Text Query with Numeric Value Comparison</h4>
<p>For each book with "usability" in the book title, return its
book title and the round number of its suggested price if the price
exceeds $25.</p>
<p>This query finds a word and contains a conditional return based
on a function on a numeric value.</p>
<ul>
<li>
<p>Operands: "usability"</p>
</li>
<li>
<p>Functionality: word query, round(), numeric value comparison,
conditional expression</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title, ./metadata/price</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, ./metadata/price</p>
</li>
<li>
<p>Comments: This query finds the word "usability" in the title of
a book, then returns the round number of its price if the price
exceeds a specified value.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book/books/book[./metadata/title ftcontains 
    "usability"]
return &lt;book number="{$book/@number}"&gt;
           {$book/metadata/title,  
             if ($book/metadata/price &gt; 25)
             then &lt;price&gt;{concat("$", round($book/metadata/price))}&lt;/price&gt;
             else ()
           }   
       &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
   and <span class="found">Usability</span> Testing&lt;/title&gt;
   &lt;price&gt;$26&lt;/price&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;<span class=
"found">Usability</span> 
   Basics: How to Plan for and Conduct <span class=
"found">Usability</span> Tests 
   on Web Site Thereby Improving the <span class=
"found">Usability</span> of Your 
   Web Site&lt;/title&gt;
   &lt;price&gt;$174&lt;/price&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q5" id=
"xquery-xpath-composability-queries-results-q5"></a>16.2.5 Q5
Full-Text Query with Character String Query</h4>
<p>Find all introductions in books, published in "Washington,
D.C.", which include listings for "résumés", "drafts", and
"correspondence".</p>
<p>This query finds words and a character string.</p>
<ul>
<li>
<p>Operands: "résumés" "drafts" "correspondence" character string
"Washington, D.C."</p>
</li>
<li>
<p>Functionality: word query, with diacritics as written in the
query, <code>and</code> query, character string query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/introduction,
./metadata/publicationInfo/place</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, ./content//introduction</p>
</li>
<li>
<p>Comments: This query performs a full-text query when it needs to
find word variants in full text and performs a character string
query when word variants are not possible.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[.//publicationInfo/place/text() 
   = "Washington, D.C."]
let $intro := $book/content/introduction[. ftcontains 
   ("résumés" diacritics sensitive) ftand "drafts" ftand "correspondence"]
where count($intro)&gt;0
return &lt;book number="{$book/@number}"&gt; 
           {$book/metadata/title, $intro}
        &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="3"&gt;
   &lt;title shortTitle="Usabilityguy Manuscript 
   Guide"&gt;John Wesley Usabilityguy: A Register of 
   His Papers&lt;/title&gt; 
   &lt;introduction&gt;
      &lt;p&gt;The papers of John Wesley Usabilityguy span the 
      years 1946-1999, with the bulk of the items
      concentrated in the period from 1985 to 1999. The 
      papers feature his career as a developer of software 
      applications and usability specialist. The collection 
      consists of <span class=
"found">correspondence</span>, memoranda, journals, 
      speeches, article <span class=
"found">drafts</span>, book drafts, notes, charts, 
      graphs, family papers, clippings, printed matter, 
      photographs, <span class=
"found">résumés</span> and other materials.&lt;/p&gt;
   &lt;/introduction&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q6" id=
"xquery-xpath-composability-queries-results-q6"></a>16.2.6 Q6
Full-Text Query with Conditional Return of Boolean Values</h4>
<p>For each book on "usability" return the book title and a new
<code>has-publishers</code> element with value <code>true</code> if
the book has more than 1 publisher. Return the title and a new
<code>has-publishers</code> element with value <code>false</code>
if the book does not have more than one publisher.</p>
<p>This query finds a word, then returns Boolean values based on
the number of occurrences of an element.</p>
<ul>
<li>
<p>Operands: "usability"</p>
</li>
<li>
<p>Functionality: word query, construction of new Boolean values,
construction of new element, count, &gt;, conditional
expression</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, has-publishers (constructed
element)</p>
</li>
<li>
<p>Comments: This query finds "usability" in the title of a book,
then returns the title and Boolean values showing whether the book
has more than one publisher or not.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[./metadata/title ftcontains 
   "usability"]
return &lt;book number="{$book/@number}"&gt;
          {$book/metadata/title} 
          &lt;has-publishers&gt; 
             {if (count($book//publisher) &gt; 1) 
             then "true" else "false"}
          &lt;/has-publishers&gt;
       &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title&gt;Improving the <span class=
"found">Usability</span> of a Web Site Through 
   Expert Reviews and <span class=
"found">Usability</span> Testing&lt;/title&gt; 
   &lt;has-publishers&gt;false&lt;/has-publishers&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;<span class="found">Usability</span> 
   Basics: How to Plan for and Conduct <span class=
"found">Usability</span> Tests 
   on Web Site Thereby Improving the <span class=
"found">Usability</span> of Your 
   Web Site&lt;/title&gt;
   &lt;has-publishers&gt;true&lt;/has-publishers&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q7" id=
"xquery-xpath-composability-queries-results-q7"></a>16.2.7 Q7
Full-Text Query with Date Comparison and Element Occurrence
Count</h4>
<p>Find all books about conducting "usability tests" which have
more than one author and are published after "2000".</p>
<p>This query finds a phrase, counts the number of occurrences of
an element, runs a greater than comparison on dates, and combines
the results.</p>
<ul>
<li>
<p>Operands: "usability testing", "2000"</p>
</li>
<li>
<p>Functionality: phrase query, character wildcard (suffix) (0 or
more), count, &gt;</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/subjects/subject, ./metadata/author,
./metadata/publicationInfo/dateIssued|dateRevised</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, ./metadata/author,
./metadata/subjects/subject</p>
</li>
<li>
<p>Comments: This is a full-text query on the phrase "usability
testing" using a wildcard on the word "test", restricted to the
<code>subject</code> element. The query counts the number of
<code>author</code> elements, and runs a greater than comparison on
dates.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
   [((./metadata/publicationInfo/dateIssued &gt; "2000-12-31") 
   or (./metadata/publicationInfo/dateRevised &gt; "2000-12-31")) 
   and count(./metadata/author) &gt; 1]
let $subj := $book//subject[. ftcontains "usability test.*" 
   with wildcards]
where count($subj)&gt;0
return &lt;book number="{$book/@number}"&gt; 
          {$book/metadata/title, $book/metadata/author, $subj}
       &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the Usability of a Web Site Through Expert Reviews and 
   Usability Testing&lt;/title&gt;
   &lt;author&gt;Millicent Marigold&lt;/author&gt;
   &lt;author&gt;Morley Marigold&lt;/author&gt;
   &lt;subject&gt;<span class=
"found">Usability testing</span>&lt;/subject&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q8" id=
"xquery-xpath-composability-queries-results-q8"></a>16.2.8 Q8 Query
with XPath Expression Within Full-Text Expression</h4>
<p>Find all books published after "2001" which share a subject with
the book with the short title "Usability Basics".</p>
<p>This query finds words using an XPath expression to identify the
words queried and looks for a publication date after the one
specified.</p>
<ul>
<li>
<p>Operands: "Usability Basics", "2001"</p>
</li>
<li>
<p>Functionality: phrase query, <code>and</code> query, date
comparisons, XPath expression to identify the words queried.</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title/@shortTitle,
./metadata/subjects/subject,
./metadata/publicationInfo/dateIssued|dateRevised</p>
</li>
<li>
<p>Return: ./metadata/title, ./metadata/author</p>
</li>
<li>
<p>Comments: This query returns a book if its last date of
publication is after 2001 and one of its subjects is the same as a
subject of the book with the short title "Usability Basics". This
query uses an XPath expression to dynamically find the subjects of
books.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
let $books := doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $bookSubject := 
   $books/metadata[./title/@shortTitle 
   ftcontains "Usability Basics"]/subjects/subject
for $book in $books   
where $book/metadata/publicationInfo/dateIssued &gt; 2001 or
     $book/metadata/publicationInfo/dateRevised &gt; 2001 and
     $book/metadata/subjects/subject ftcontains 
     {$bookSubject} any
return
        &lt;book number="{$book/@number}"&gt;
           {$book/metadata/title,
           $book/metadata/author}
        &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the Usability of a Web Site Through Expert Reviews and 
   Usability Testing&lt;/title&gt;
   &lt;author&gt;Millicent Marigold&lt;/author&gt;
   &lt;author&gt;Morley Marigold&lt;/author&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;title shortTitle="Usabilityguy Manuscript 
   Guide"&gt;John Wesley Usabilityguy: A Register of His 
   Papers&lt;/title&gt;     
   &lt;author&gt;Millicent Marigold&lt;/author&gt;
   &lt;author&gt;Morty Marigold&lt;/author&gt; 
&lt;book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q9" id=
"xquery-xpath-composability-queries-results-q9"></a>16.2.9 Q9 Query
Using an XQuery Expression to Determine the Number of Words Allowed
in a Window</h4>
<p>Find all books which discuss "successfully completing
tasks".</p>
<p>This query finds words within a window, allowing more words
within the window depending on the number of chapters in the
book.</p>
<ul>
<li>
<p>Operands: "successfully" "completing" "tasks"</p>
</li>
<li>
<p>Functionality: word query, stemming, unordered window of at most
(number of chapters in the book times 3) words</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: ./metadata/title, ./content</p>
</li>
<li>
<p>Comments: This query uses an XQuery expression to determine the
number of words in an unordered window. It allows more words in the
window when there are more chapters in the book. The query does not
return "tasks which are critical for users to be able to complete
successfully" from Book 2, because there are three chapters in Book
2 which multiplied by three allows up to nine words within the
window, not the 12 in the quoted phrase.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
for $cont := $book/content[. ftcontains ("successfully" 
   ftand "completing" ftand "tasks") with stemming
   window (count(./contents/part/chapter) * 3) 
   words] 
where count($cont)&gt;0
return ($book/metadata/title, $cont)
</pre></div>
<p><em>Solution in XPath</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[count(./content ftcontains ("successfully" 
ftand "completing" ftand "tasks") with stemming
window  (count(./contents/part/chapter) * 3)
words)&gt;0]/(./metadata/title|./content)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;
&lt;content&gt;
   ...
   &lt;part number="1"&gt;
      &lt;chapter&gt;
         &lt;title&gt;Planning then Conducting Usability
         Tests&lt;/title&gt; 
         &lt;p&gt;Take the following steps to plan usability 
         testing. &lt;step number="1"&gt;Clarify and 
         articulate the goal of the usability testing.
         &lt;/step&gt; &lt;step number="2"&gt;Identify <span class=
"found">tasks</span> which 
         are critical for users to be able to <span class=
"found">complete</span>  
         <span class=
"found">successfully</span> .&lt;/step&gt; &lt;step number="3"&gt;Compile 
         a script of questions or instructions which 
         will prompt the user to attempt those 
         tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
         users and begin recruiting them.&lt;/step&gt; &lt;step 
         number="5"&gt;Conduct a pretest on a few users.
         &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
         on insights gleaned from the pretest.&lt;/step&gt; 
         &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
      &lt;/chapter&gt;
   &lt;/part&gt;
   ...
&lt;/content&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Score" id="Score"></a>17 Use Case "SCORE": All Queries
May Be Written with Score, Queries in this Section Must Be Written
with Score</h2>
<div class="div2">
<h3><a name="score-description" id="score-description"></a>17.1
Description</h3>
<p>All the queries in these Use Cases may be written with or
without score. The Use Cases in this section are merely a small
subset that focuses on score.</p>
<p>These queries exploit score and can not be written as queries
with pure Boolean full-text predicates. Among these queries are a
query that computes and returns only scores, a query which returns
only results over a specified threshold, a query which filters by
score, a query which returns all the documents ordered, and a query
which uses weighting to impact scoring and sorting.</p>
<p>Scoring methodologies will not be defined in this
recommendation. Scoring is implementation-defined.</p>
</div>
<div class="div2">
<h3><a name="score-queries-results" id=
"score-queries-results"></a>17.2 Queries and Results</h3>
<div class="div3">
<h4><a name="score-queries-results-q1" id=
"score-queries-results-q1"></a>17.2.1 Q1 Query Returning
Scores</h4>
<p>Find all books which mention "usability" in the title or the
text. Return book titles and scores.</p>
<p>This query performs a word query and returns scores, highest
scores first.</p>
<ul>
<li>
<p>Operands: "usability"</p>
</li>
<li>
<p>Functionality: word query, implementation-defined scoring,
returns score, construction of new element</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title, ./content</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, score (constructed
element)</p>
</li>
<li>
<p>Comments: This query is only possible as a scored query. Scores
are included between 0 and 1. The scoring methodology in this use
case is for illustrative purposes only. Scoring methodologies will
be implementation-defined. This query returns the same results as a
query with a pure Boolean full-text predicate. The difference is
that the results are scored and the results are returned displaying
the score and ranked by score.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
  /books/book
let score $s := ($book/metadata/title ftcontains 
   "usability" or $book/content ftcontains "usability") 
where $s &gt; 0  
order by $s descending 
return &lt;book number="{$book/@number}"&gt; 
          {$book/metadata/title},  &lt;score&gt;{$s}&lt;/score&gt; 
       &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;<span class=
"found">Usability</span> 
   Basics: How to Plan for and Conduct <span class=
"found">Usability</span> Tests 
   on Web Site Thereby Improving the <span class=
"found">Usability</span> of Your 
   Web Site&lt;/title&gt;
   &lt;score&gt;0.9&lt;/score&gt;
&lt;/book&gt;

&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
   and <span class="found">Usability</span> Testing&lt;/title&gt;
   &lt;score&gt;0.8&lt;/score&gt;
&lt;/book&gt;
   
&lt;book number="3"&gt;
   &lt;title shortTitle="Usabilityguy Manuscript 
   Guide"&gt;John Wesley Usabilityguy: A Register of His 
   Papers&lt;/title&gt;    
   &lt;score&gt;0.12&lt;/score&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="score-queries-results-q2" id=
"score-queries-results-q2"></a>17.2.2 Q2 Query Returning Results
with Top Scores</h4>
<p>Find the best two books on "usability".</p>
<p>This query performs a word query and returns only the results
with the two top scores.</p>
<ul>
<li>
<p>Operands: "usability"</p>
</li>
<li>
<p>Functionality: word query, implementation-defined scoring,
returns books with the top two scores, conditional expression</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title</p>
</li>
<li>
<p>Comments: This query returns results only for the two books with
the highest scores. This query is only possible as a scored query.
The scoring methodology in this use case is for illustrative
purposes only. Scoring methodologies will be
implementation-defined. This query returns the same results as a
query with a pure Boolean full-text predicate. The difference is
that the results are scored and through the introduction of a third
variable only the two results with the highest scores are
returned.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $result at $i in
     for $book score $s in 
        doc("http://bstore1.example.com/full-text.xml")
        /books/book[. ftcontains "usability"]
      order by $s descending
      return $book
   where $i &lt;= 2
   return &lt;book number="{$result/@number}"&gt; 
      $result/metadata/title&lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
   and <span class="found">Usability</span> Testing&lt;/title&gt;
&lt;/book&gt;
   
&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;<span class=
"found">Usability</span> 
   Basics: How to Plan for and Conduct <span class=
"found">Usability</span> Tests 
   on Web Site Thereby Improving the <span class=
"found">Usability</span> of Your 
   Web Site&lt;/title&gt; 
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="score-queries-results-q3" id=
"score-queries-results-q3"></a>17.2.3 Q3 Query Filtering on
Scores</h4>
<p>Find all books that focus on "usability".</p>
<p>This query performs a word query and filters on scores.</p>
<ul>
<li>
<p>Operands: "usability"</p>
</li>
<li>
<p>Functionality: word query, implementation-defined scoring,
filters on scores (accepts only those with score over 0.1)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title</p>
</li>
<li>
<p>Comments: This query is only possible as a scored query. The
scoring methodology in this use case is for illustrative purposes
only. Scoring methodologies will be implementation-defined. This
query returns the same results as a query with a pure Boolean
full-text predicate. The difference is that the results are scored
and then filtered on the scores.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book score $s in 
   doc("http://bstore1.example.com/full-text.xml")
   /books/book[. ftcontains "usability"]
where $s &gt; 0.1
return $book/metadata/title
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[(for $i score $s in .[. ftcontains "usability"]
return $s) &gt; 0.1]/metadata/title
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
and <span class="found">Usability</span> Testing&lt;/title&gt;

&lt;title shortTitle="Usability Basics"&gt;<span class=
"found">Usability</span> 
Basics: How to Plan for and Conduct <span class=
"found">Usability</span> Tests 
on Web Site Thereby Improving the <span class=
"found">Usability</span> of Your 
Web Site&lt;/title&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="score-queries-results-q4" id=
"score-queries-results-q4"></a>17.2.4 Q4 Query Combining Score and
XML Structure with a Conditional Return</h4>
<p>Find all books with parts about "usability testing".</p>
<p>This query finds books which contain parts about usability
testing, returning entire books, but without <code>part</code>
elements identified as irrelevant via score.</p>
<ul>
<li>
<p>Operands: "usability testing"</p>
</li>
<li>
<p>Functionality: phrase query, character wildcard (suffix) (0 or
more), implementation-defined scoring, filters on scores (under
.05), conditional return</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/part</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, ./content/part/@number,
./content/part//title, ./content/part/p</p>
</li>
<li>
<p>Comments: This query is only meaningful as a scored query. The
scoring methodology in this use case is for illustrative purposes
only. Scoring methodologies will be implementation-defined. This
query returns the same results as a query with a pure Boolean
full-text predicate. The difference is that this query filters the
<code>part</code> elements. They are included or excluded from the
results depending on their score.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
declare function local:filter ( $nodes 
   as node()*, $exclude as element()* ) as node()*
   {
      for $node in $nodes except $exclude
      return
         typeswitch ($node)
            case $e as element()
               return 
                 element {node-name($e)}
                   {
                       $e/@*,
                      filter( $e/node() except $exclude, 
                      $exclude )
                   }
            default 
               return $node
   };

for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $irrelevantParts := 
   for $part in $book//part
   let score $score := $part ftcontains "usability test.*" 
      with wildcards
   where $score &lt; 0.5
   return $part
where count($irrelevantParts) &lt; count($book//part)
return filter($book, $irrelevantParts)
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;author&gt;Elina Rose&lt;/author&gt;
         &lt;p&gt;The usability of a Web site is how well the 
         site supports the user in achieving specified 
         goals. A Web site should facilitate learning, 
         and enable efficient and effective task 
         completion, while propagating few errors. 
         Satisfaction with the site is also important. 
         The user must not only be well-served, but must 
         feel well-served.&lt;/p&gt; 
         &lt;p&gt;Expert reviews and <span class=
"found">usability testing</span> are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them away from your site.&lt;/p&gt;
         &lt;p&gt;The most successful projects employ multiple 
         methods in multiple iterations. As Millicent 
         Marigold remarked during a recent conference, 
         "Don't stop. Iterate, iterate, then iterate 
         again."&lt;/p&gt;
         &lt;p&gt;This book has been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      ...
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;<span class=
"found">Usability Testing</span>&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some tests of the site with your unique 
            audience or audiences by conducting <span class=
"found">usability</span> 
            <span class="found">testing</span>.&lt;/p&gt;
            &lt;p&gt;Users are asked to complete tasks which 
            measure the success of the information 
            architecture and navigational elements of the 
            site.&lt;/p&gt;
            &lt;p&gt;Then changes are made to improve service to 
            users.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability tests on Web sites. Usability 
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         &lt;p&gt;This book has not been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting <span class=
"found">Usability</span> 
            <span class="found">Tests</span>&lt;/title&gt; 
            &lt;p&gt;Take the following steps to plan <span class=
"found">usability</span>
            <span class=
"found">testing</span>. &lt;step number="1"&gt;Clarify and 
            articulate the goal of the <span class=
"found">usability testing</span>.
            &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
            are critical for users to be able to complete 
            successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
            a script of questions or instructions which 
            will prompt the user to attempt those 
            tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
            users and begin recruiting them.&lt;/step&gt; &lt;step 
            number="5"&gt;Conduct a pretest on a few users.
            &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
            on insights gleaned from the pretest.&lt;/step&gt; 
            &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting <span class=
"found">Usability Tests</span>&lt;/title&gt; 
            &lt;p&gt;Users can be tested at any computer 
            workstation &lt;footnote&gt;They may be more 
            comfortable at their own workstation than in 
            a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;<span class=
"found">Usability</span> 
            <span class=
"found">testing</span> can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no guidance or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in Web site components which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of testing and changes, until 
            users are successful in the accomplishing the 
            tasks.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="score-queries-results-q5" id=
"score-queries-results-q5"></a>17.2.5 Q5 Query Returning All Books
Ordered by Score</h4>
<p>Return all books, listing books with text on "software"
first.</p>
<p>This query performs a word query, returns all the documents in
the database, and orders them returning those with found word
first, those without last.</p>
<ul>
<li>
<p>Operands: "software"</p>
</li>
<li>
<p>Functionality: word query, implementation-defined scoring</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, .</p>
</li>
<li>
<p>Comments: This query is only meaningful as a scored query. The
scoring methodology in this use case is for illustrative purposes
only. Scoring methodologies will be implementation-defined. This
query returns the more results than a parallel query with a pure
Boolean full-text predicate. In a parallel query with a pure
Boolean full-text predicate, the last result would have a Boolean
value of false and would not be returned. In this scored query the
last result receives a score and is returned.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let score $s := $book//content ftcontains "software"
order by $s descending
return $book
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;      
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         &lt;introduction&gt;
            ...                                                                 
            &lt;p&gt;Expert review methods should be
            initiated early in the development process, 
            as soon as paper &lt;b&gt;p&lt;/b&gt;rototypes
            (hand-drawn pictures of Web pages) or
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are
            available. They should be conducted using
            the hardware and <span class=
"found">software</span> similar to that 
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
      &lt;/part&gt; 
      ...
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;   
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of <span class=
"found">software</span> 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;      
      ...
   &lt;content&gt;      
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="score-queries-results-q6" id=
"score-queries-results-q6"></a>17.2.6 Q6 Query with Weight
Declaration</h4>
<p>Finds books which discuss "conducting usability tests" returning
those which mention "measuring success" first.</p>
<p>This query finds words using weighting on optional words to
impact the scoring and sorting.</p>
<ul>
<li>
<p>Operands: "conduct" "usability" "tests" "measuring"
"success"</p>
</li>
<li>
<p>Functionality: word queries, stemming, unordered distance (0 to
10 intervening words between "conduct" and "usability" and between
"usability" and "tests"), unordered distance (0 to 4 intervening
words between "measuring" and "success"), weight declaration</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: ./metadata/title, ./content</p>
</li>
<li>
<p>Comments: This query returns books on "conducting usability
tests", using a weight declaration to return books with mentions of
"measuring success" higher in the sort.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $booktext := $book/content[. ftcontains 
   "conduct" ftand "usability" ftand "tests"
   with stemming distance at most 10 words]
let score $s := $booktext ftcontains 
   "measuring" ftand "success" with stemming distance
   at most 4 words weight 0.8
where count($booktext) &gt; 0
order by $s
return ($book/metadata/title, $booktext)
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
the Usability of a Web Site Through Expert Reviews 
and Usability Testing&lt;/title&gt;
&lt;content&gt;
   ...
   &lt;part number="2"&gt;
      &lt;chapter&gt;
         &lt;title&gt;Usability Testing&lt;/title&gt;
         &lt;p&gt;Once the problems identified by expert 
         reviews have been corrected, it is time to 
         conduct some tests of the site with your unique 
         audience or audiences by <span class=
"found">conducting usability</span> 
         <span class="found">testing</span>.&lt;/p&gt;
         &lt;p&gt;Users are asked to complete tasks which 
         <span class="found">measure</span> the <span class=
"found">success</span> of the information 
         architecture and navigational elements of the 
         site.&lt;/p&gt;
         &lt;p&gt;Then changes are made to improve service to 
         users.&lt;/p&gt;
      &lt;/chapter&gt;
   &lt;/part&gt; 
&lt;/content&gt;

&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;
&lt;content&gt;
   &lt;introduction&gt;
      &lt;p&gt;This is a basic handbook for planning and 
      <span class=
"found">conducting usability tests</span> on Web sites. Usability 
      testing should be used in conjunction with other 
      expert review methods.&lt;/p&gt;
      &lt;p&gt;This book has not been approved by the Web Site 
      Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
   &lt;part number="1"&gt;
      &lt;chapter&gt;
         &lt;title&gt;Planning then <span class=
"found">Conducting Usability</span> 
         <span class="found">Tests</span>&lt;/title&gt; 
         &lt;p&gt;Take the following steps to plan usability 
         testing. &lt;step number="1"&gt;Clarify and 
         articulate the goal of the usability testing.
         &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
         are critical for users to be able to complete 
         successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
         a script of questions or instructions which 
         will prompt the user to attempt those 
         tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
         users and begin recruiting them.&lt;/step&gt; &lt;step 
         number="5"&gt;Conduct a pretest on a few users.
         &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
         on insights gleaned from the pretest.&lt;/step&gt; 
         &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
      &lt;/chapter&gt;
   &lt;/part&gt;
   &lt;part number="2"&gt;
      &lt;chapter&gt;
         &lt;title&gt;<span class=
"found">Conducting Usability Tests</span>&lt;/title&gt; 
         &lt;p&gt;Users can be tested at any computer 
         workstation &lt;footnote&gt;They may be more 
         comfortable at their own workstation than in 
         a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
         &lt;p&gt;Give the user the script, then assure them 
         that you are testing the Web site, not them. 
         Users are asked to verbalize their thoughts as 
         they complete the tasks. The event is recorded 
         or someone takes notes. It is often preferable 
         to have two testers, &lt;footnote&gt;Usability 
         testing can be done at great expense or on a 
         shoe string, using &lt;testingProcedure&gt;in-house 
         expertise&lt;/testingProcedure&gt; or 
         &lt;testingProcedure&gt;contracting with human 
         computer interaction professionals
         &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
         questions, another to take notes. Testers should 
         offer no guidance or comments to the user. Mouse 
         movements, typing, expressions, and the user's 
         words should be recorded.&lt;/p&gt;
      &lt;/chapter&gt;
      ...
   &lt;/part&gt;
&lt;/content&gt;
</pre></div>
</div>
</div>
</div>
</div>
<div class="back">
<div class="div1">
<h2><a name="Acknowledgements" id="Acknowledgements"></a>A
Acknowledgements</h2>
<p>The editors thank the members of the Full Text Task Force of the
XML Query and XSL Working Groups, which produced the material in
this document. Special thanks to Stephen Buxton for contributing
the first version of the schema.</p>
<p>The editors thank the following staff at the Library of Congress
for providing and improving sample data and queries: Ardith
Bausenbach, Caroline Arms, Marla Banks, Susan David, Ray Denenberg,
Louis Drummond, Bohdan Kantor, Mary A. Lacy, Joe Pagano, Betsy
Reifsnyder, Belinda D. Urquiza, and Anne Washington.</p>
<p>Thanks also to Bohdan Kantor, Foster Zhang, François Yergeau,
and Michel Biezunski for assistance in translating the subjects in
the sample data into Chinese and French.</p>
<p>The editors also wish to thank the members of the W3C
Internationalization Working Group for their assistance.</p>
</div>
<div class="div1">
<h2><a name="References" id="References"></a>B References</h2>
<div class="div2">
<h3><a name="primary" id="primary"></a>B.1 References
(Primary)</h3>
<p>The following references are some of the works considered by the
Working Groups in deriving its use cases.</p>
<dl>
<dt class="label"><span><a name="xpath-functions" id=
"xpath-functions"></a>XQuery 1.0 and XPath 2.0 Functions and
Operators</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xpath-functions/"><cite>XQuery
1.0 and XPath 2.0 Functions and Operators</cite></a>, Ashok
Malhotra, Jim Melton, and Norman Walsh, Editors. World Wide Web
Consortium, 23 Jan 2007. This version is
http://www.w3.org/TR/2007/REC-xpath-functions-20070123/. The
<a href="http://www.w3.org/TR/xpath-functions/">latest version</a>
is available at http://www.w3.org/TR/xpath-functions/.</div>
</dd>
<dt class="label"><span><a name="xml-infoset" id=
"xml-infoset"></a>Infoset</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xml-infoset"><cite>XML
Information Set (Second Edition)</cite></a>, John Cowan and Richard
Tobin, Editors. World Wide Web Consortium, 04&#160;Feb&#160;2004.
This version is http://www.w3.org/TR/2004/REC-xml-infoset-20040204.
The <a href="http://www.w3.org/TR/xml-infoset">latest version</a>
is available at http://www.w3.org/TR/xml-infoset.</div>
</dd>
<dt class="label"><span><a name="Maier98" id=
"Maier98"></a>Maier98</span></dt>
<dd>
<div><em><a href=
"http://www.w3.org/TandS/QL/QL98/pp/maier.html">Database Desiderata
for an XML Query Language</a>,</em> David Maier, 1998. In Query
Languages 98 (QL'98). This paper is at
http://www.w3.org/TandS/QL/QL98/pp/maier.html.</div>
</dd>
<dt class="label"><span><a name="REC-xml" id=
"REC-xml"></a>XML</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xml"><cite>Extensible Markup
Language (XML) 1.0 (Fourth Edition)</cite></a>, Eve Maler, Jean
Paoli, François Yergeau, <em>et. al.</em>, Editors. World Wide Web
Consortium, 16&#160;Aug&#160;2006. This version is
http://www.w3.org/TR/2006/REC-xml-20060816. The <a href=
"http://www.w3.org/TR/xml">latest version</a> is available at
http://www.w3.org/TR/xml.</div>
</dd>
<dt class="label"><span><a name="xmlschema-0" id=
"xmlschema-0"></a>XMLSchema0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xmlschema-0/"><cite>XML Schema
Part 0: Primer Second Edition</cite></a>, David C. Fallside and
Priscilla Walmsley, Editors. World Wide Web Consortium,
28&#160;Oct&#160;2004. This version is
http://www.w3.org/TR/2004/REC-xmlschema-0-20041028/. The <a href=
"http://www.w3.org/TR/xmlschema-0/">latest version</a> is available
at http://www.w3.org/TR/xmlschema-0/.</div>
</dd>
<dt class="label"><span><a name="xmlschema-1" id=
"xmlschema-1"></a>XMLSchema1</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xmlschema-1/"><cite>XML Schema
Part 1: Structures Second Edition</cite></a>, Henry S. Thompson,
David Beech, Noah Mendelsohn, and Murray Maloney, Editors. World
Wide Web Consortium, 28&#160;Oct&#160;2004. This version is
http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/. The <a href=
"http://www.w3.org/TR/xmlschema-1/">latest version</a> is available
at http://www.w3.org/TR/xmlschema-1/.</div>
</dd>
<dt class="label"><span><a name="xmlschema-2" id=
"xmlschema-2"></a>XMLSchema2</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xmlschema-2/"><cite>XML Schema
Part 2: Datatypes Second Edition</cite></a>, Paul V. Biron and
Ashok Malhotra, Editors. World Wide Web Consortium,
28&#160;Oct&#160;2004. This version is
http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/. The <a href=
"http://www.w3.org/TR/xmlschema-2/">latest version</a> is available
at http://www.w3.org/TR/xmlschema-2/.</div>
</dd>
<dt class="label"><span><a name="xquery" id="xquery"></a>XQuery
1.0: An XML Query Language</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xquery/"><cite>XQuery 1.0: An
XML Query Language</cite></a>, Don Chamberlin , Anders Berglund,
Scott Boag, <em>et. al.</em>, Editors. World Wide Web Consortium,
23 Jan 2007. This version is
http://www.w3.org/TR/2007/REC-xquery-20070123/. The <a href=
"http://www.w3.org/TR/xquery/">latest version</a> is available at
http://www.w3.org/TR/xquery/.</div>
</dd>
<dt class="label"><span><a name="xquery-use-cases" id=
"xquery-use-cases"></a>XML Query Use Cases</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xquery-use-cases/"><cite>XML
Query Use Cases</cite></a>, Jonathan Robie, Don Chamberlin, Peter
Fankhauser, <em>et. al.</em>, Editors. World Wide Web Consortium, 8
Jun 2006. This version is
http://www.w3.org/TR/2006/WD-xquery-use-cases-20060608/. The
<a href="http://www.w3.org/TR/xquery-use-cases/">latest version</a>
is available at http://www.w3.org/TR/xquery-use-cases/.</div>
</dd>
<dt class="label"><span><a name="xqueryft-requirements" id=
"xqueryft-requirements"></a>XQuery and XPath Full Text
Requirements</span></dt>
<dd>
<div><em><a href=
"http://www.w3.org/TR/xpath-full-text-10-requirements/">XQuery and
XPath Full Text Requirements</a></em>, Stephen Buxton, Michael Rys,
Editors. World Wide Web Consortium, 18 May 2007. This version is
http://www.w3.org/TR/2007/WD-xpath-full-text-10-requirements-20070518/.
The <a href=
"http://www.w3.org/TR/xpath-full-text-10-requirements/">latest
version</a> is available at <a href=
"http://www.w3.org/TR/xpath-full-text-10-requirements/">http://www.w3.org/TR/xpath-full-text-10-requirements/</a>.</div>
</dd>
<dt class="label"><span><a name="xquery-full-text" id=
"xquery-full-text"></a>XQuery and XPath Full Text 1.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xquery-full-text/"><cite>XQuery
1.0 and XPath 2.0 Full-Text</cite></a>, Pat Case, Sihem Amer-Yahia,
Chavdar Botev, <em>et. al.</em>, Editors. World Wide Web
Consortium, 1 May 2006. This version is
http://www.w3.org/TR/2006/WD-xquery-full-text-20060501/. The
<a href="http://www.w3.org/TR/xquery-full-text/">latest version</a>
is available at http://www.w3.org/TR/xquery-full-text/.</div>
</dd>
<dt class="label"><span><a name="xpath20" id="xpath20"></a>XML Path
Language (XPath) 2.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xpath20/"><cite>XML Path
Language (XPath) 2.0</cite></a>, Don Chamberlin , Anders Berglund,
Scott Boag, <em>et. al.</em>, Editors. World Wide Web Consortium,
23 Jan 2007. This version is
http://www.w3.org/TR/2007/REC-xpath20-20070123/. The <a href=
"http://www.w3.org/TR/xpath20/">latest version</a> is available at
http://www.w3.org/TR/xpath20/.</div>
</dd>
<dt class="label"><span><a name="xslt20" id="xslt20"></a>XSL
Transformations (XSLT) Version 2.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xslt20"><cite>XSL
Transformations (XSLT) Version 2.0</cite></a>, Michael Kay, Editor.
World Wide Web Consortium, 23 Jan 2007. This version is
http://www.w3.org/TR/2007/REC-xslt20-20070123/. The <a href=
"http://www.w3.org/TR/xslt20/">latest version</a> is available at
http://www.w3.org/TR/xslt20/.</div>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="background" id="background"></a>B.2 References
(Background)</h3>
<dl>
<dt class="label"><span><a name="BYR99" id=
"BYR99"></a>BYR99</span></dt>
<dd>
<div><em>Modern Information Retrieval,</em> R.Baeza-Yates, B.
Ribeiro-Neto. Addison Wesley, 1999.</div>
</dd>
<dt class="label"><span><a name="FGR01" id=
"FGR01"></a>FGR01</span></dt>
<dd>
<div><em>XIRQL: An Extension of XQL for Information Retrieval,</em>
N. Fuhr, K. Grossjohann. Proceedings of SIGIR, 2001.</div>
</dd>
<dt class="label"><span><a name="HTK00" id=
"HTK00"></a>HTK00</span></dt>
<dd>
<div><em>Searching Text-Rich XML Documents with Relevance
Ranking,</em> Y. Hayashi, J. Tomita, G. Kikui. Proceedings of SIGIR
Workshop on XML and Information Retrieval, 2000.</div>
</dd>
<dt class="label"><span><a name="MJK98" id=
"MJK98"></a>MJK98</span></dt>
<dd>
<div><em>A Flexible Model for Retrieval of SGML Documents,</em> S.
Myaeng, D.-H. Jang, M.-S. Kim, Z.-C. Zhoo. Proceedings of SIGIR,
1998.</div>
</dd>
<dt class="label"><span><a name="SCH01" id=
"SCH01"></a>SCH01</span></dt>
<dd>
<div><em>Similarity Search in XML Data Using Cost-Based Query
Transformations,</em> T. Schlieder. Proceedings of SIGMOD WebDB
Workshop, 2001.</div>
</dd>
<dt class="label"><span><a name="TWE00" id=
"TWE00"></a>TWE00</span></dt>
<dd>
<div><em>Adding Relevance to XML,</em> A. Theobald and G. Weikum.
Proceedings of SIGMOD WebDB Workshop, 2000.</div>
</dd>
</dl>
</div>
</div>
<div class="div1">
<h2><a name="ChangeLog" id="ChangeLog"></a>C Change Log</h2>
<table border="0" summary="Change Log Table">
<tbody>
<tr>
<td>Pat Case</td>
<td>2003-06-18</td>
<td>Added a Change Log</td>
<td></td>
</tr>
<tr>
<td>Pat Case</td>
<td>2003-06-18</td>
<td>Statements of Functionality Illustrated by Query Modified</td>
<td>Added a Data Context to the Statement of Functionality
Illustrated by Query for each query. Made XPath expressions in
Query Context and Return relative to the XPath expression in Data
Context.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2003-06-18</td>
<td>Schema Modified</td>
<td>Replaced schema with a shorter one which defines more shared
types.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2003-06-18</td>
<td>New Use Cases Added</td>
<td>Added the following Use Cases: 3.2.11 Q11 Query on Entire
Document, 14.2.11 Q11 Phrase Query Ignoring Explicit List of Tags
and Content of Descendant Elements.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2003-06-23</td>
<td>New Use Case Added</td>
<td>Added the following Use Case: 16.2.7 Q7 Query on Full Text
Combined with Conditional on Date and Full Text.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2004-02-24</td>
<td>Solutions in XQuery Added</td>
<td>Added Solutions in XQuery authored by Full Text Task Force
Members.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2004-02-24</td>
<td>Use Case Removed</td>
<td>Removed the following Use Case: 2.2.3 Q3 Single Phrase Query on
Long Text Excerpt.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2004-02-24</td>
<td>Switched Use of Proximity and Distance</td>
<td>Proximity is now the broader term, distance (proximity counting
intervening words) and window are the narrower terms.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2004-02-24</td>
<td>Added Definition of the Word "Tag"</td>
<td>Added definition of the word "tag" to the introduction to the
Ignore Section (subsequently moved to the Across Element Boundaries
Section).</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2004-03-15</td>
<td>Edited Solutions in XQuery</td>
<td>Made changes such as removing operators and unnecessary
parentheses, made stopwords stop words, etc.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2004-03-15</td>
<td>Query Statements and Expected Results Changed</td>
<td>Made extensive changes to statements of query functionality and
expected results to correlate with the new solutions.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2004-04-26</td>
<td>Use Cases Removed</td>
<td>Removed the following use cases: 3.2.1 Q1 Query on Element,
4.2.1 Q1 Query on Word Ignoring Single Stop Word, 4.2.3 Q3 Query on
Phrase Word, 4.2.4 Q4 Query on Phrase Ignoring Multiple Stop Words,
4.2.5 Q5 Query on Phrase Overriding Multiple Stop Words, 6.2.3 Q3
Single Infix Character Wildcard Query, 6.2.5 Q5 0 or More Suffix
Character Wildcard Query, 6.2.9 Q9 Word Wildcard Query, 6.2.10 Q10
Specified Range Word Wildcard Query, 9.2.2 Q2 Or Query on More Than
Two Words, 9.2.3 Q3 Or Query on Phrases, 9.2.5 Q5 And Query on More
Than Two Words, 9.2.6 Q6 And Query on Phrases, 10.2.3 Q3 Unordered
Window Query, 10.2.5 Q5 Unordered Within a Sentence Query, 10.2.7
Q7 Unordered Within a Paragraph Query, 12.2.1 Q1 Multiple Word
Query, 12.2.2 Q2 Phrase Word Query, 13.2.3 Q3 Query on Element and
Its Descendants, 13.2.4 Q4 Query on Element and Its Parent, 13.2.7
Q7 Query on Element and Its Siblings, 13.2.8 Q8 Query on Same
Element in Different Sub-Trees, 14.2.2 Q2 Query Ignoring ! Tags
Within Multiple Words, 14.2.4 Q4 Phrase Query Ignoring Explicit
List of Tags of Descendant Elements, 14.2.8 Q8 Phrase Query
Ignoring Tags and Content of Descendant Elements Identified by an
XPath Query, 14.2.10 Q10 Distance Query Ignoring All Tags and
Content of Descendant Elements, 14.2.11 Q11 Phrase Query Ignoring
Explicit List of Tags and Content of Descendant Elements.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2004-04-26</td>
<td>Reorganized sections, moved and reworked numerous use
cases.</td>
<td>Removed the Querying Words and Phrases Section and the Advanced
Word and Phrase Query Section. Added sections for Querying Across
XML Element Boundaries, Querying on Attribute Values, and Querying
Instances of Elements. Reorganized the sections so functionality is
introduced before it is used. Revised titles of sections and titles
of queries.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2004-04-26</td>
<td>Use Cases Added</td>
<td>Added the following Use Cases:13.2.6 Q6 Query Combining Score
and XML Structure with a Conditional Return, 16.2.8 Q8 Query with
an XQuery Expression Within the Full-Text Expression.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2004-04-26</td>
<td>&lt;authors&gt; Elements Removed</td>
<td>Removed the unnecessary &lt;authors&gt; elements from the
sample data, schema, and use cases.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2004-04-26</td>
<td>Solutions in XPath Added</td>
<td>Added Solutions in XPath authored by Full Text Task Force
Members.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2004-04-26</td>
<td>Query Statements and Expected Results Changed</td>
<td>Made extensive changes to statements of query functionality and
expected results to correlate with the new solutions.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2004-05-19</td>
<td>Renamed and Reversed Order of Sections</td>
<td>The INSTANCE Section was renamed CARDINALITY. The COMPOSABILITY
Section was renamed XQUERY-XPATH-COMPOSABILITY and the COMPLEX
Section was renamed FULL-TEXT-COMPOSABILITY, and their order in the
document was reversed.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2004-09-17</td>
<td>Removed Version Statements</td>
<td>Removed the "For consideration in v.1" and "For consideration
after v.1 version" statements from the Statements of functionality
illustrated by query.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2004-09-17</td>
<td>Changed queries</td>
<td>Changed query statements, solutions, and results based on
implementer feedback and Task Force decisions in the following use
cases: Use case 14.2.1. Q1 Distance Query Ignoring Content of All
Descendant Elements (changed the element whose descendants are
ignored to one with content; without content keywords must be
followed by an Exp so to ignore all of the descendants added *),
Use Case 16.2.8 Q8 Query with XQuery Expression Within Full-Text
Expression (changed all to any), Use Case 10.2.5 Q5 And Not Query
(added Book 3 as a result), Use Case 15.2.5 Q5 Query on Different
Elements in Different Sub-Trees with Conditional Return (added an
"s" to problems in a let statement, corrected the $i(s) to $in(s),
corrected the book number on the result to 1), Use Case 16.2.4 Q4
Full-Text Query with Numeric Value Comparison (added missing curly
brace in element constructor), Use Case 16.2.5 Q5 Full-Text Query
with Character String Query (changed metadata for Book 3 and the
query to look for Washington, D.C. to make the result valid), Use
Case 16.2.8 Q8 Query with XQuery Expression Within Full-Text
Expression (Changed the query statement to search the book short
title, improved the query and the comment statement), Use Case
13.2.4 Q4 Query on Element and Its Right Siblings (improved
query).</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2004-09-18</td>
<td>Added FTUnit to window function</td>
<td>Added the FTUnit "word" to query solutions using the window
function.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2004-09-22</td>
<td>Changed query in XQUERY-XPATH-COMPOSABILITY Section</td>
<td>Changed query statements, solutions, and results based on
implementer feedback and Task Force decisions in Use Case 16.2.8 Q8
Query with XQuery Expression Within Full-Text Expression. (made it
search any document not only $book, collapsed where clauses).</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2005-01-17</td>
<td>Changed score functionality</td>
<td>Changed the score functions (ft:score) to score clauses in the
SCORE Section.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2005-01-17</td>
<td>Removed use cases from CHARACTER Section</td>
<td>Removed 9.2.5 Query on Word with Special Character and 9.2.6
Query on Word with Special Character or Phrase with Space from the
CHARACTER Section.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2005-01-17</td>
<td>Updated syntax</td>
<td>Updated the syntax for wildcards, stop words, starts-with,
entire content, and thesauri.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2005-02-01</td>
<td>Added XPath example of score functionality</td>
<td>Added XPath example of score clauses in the SCORE Section Q3
Filtering on Scores.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2005-02-02</td>
<td>Removed explicit unordered</td>
<td>Removed the "unordered" keyword from unordered queries. The
default is unordered; the presence of the "ordered" keyword
overrides the default.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2005-02-10</td>
<td>Updated distance and window syntax</td>
<td>Updated distance queries removing the no longer acceptable
"with" keyword. Updated window queries removing the no longer
acceptable "within" keyword.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2005-03-09</td>
<td>Updated FTTimes syntax</td>
<td>Updated the FTTimes syntax from "at least 2 occurrences" to
"occurs at least 2 times".</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2005-03-09</td>
<td>Added syntax for embedded XQuery</td>
<td>Added syntax (curly braces "{}") around XQuery expressions
embedded in XQuery full-text expressions.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2005-03-09</td>
<td>Reformatted URLs in solutions</td>
<td>Reformatted URLs in solutions to enable automatic parsing.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2005-03-09</td>
<td>Updated thesaurus and stop words syntax</td>
<td>Updated thesaurus and stop words syntax to include the keyword
"at" before URLs.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2005-08-08</td>
<td>Changed FTMildNegation syntax</td>
<td>Changed "mild not" to "not in" in 10.27 Q7 Mild Not Query Where
Second Operand Is a Subset of the First Operand.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2005-08-25</td>
<td>Changed score syntax</td>
<td>Changed to new scoring syntaxes in Section 17. Use cases 1-4
illustrate scored queries returning the same results as a parallel
pure Boolean full-text predicate query. 17.2.5 Q5 Query Returning
All Books Ordered by Score illustrates a scored query returning
more results than a parallel pure Boolean full-text predicate
query.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2005-08-25</td>
<td>Corrected 15.2.4 Q4</td>
<td>Changed the title of 15.2.4 Q4 Distance and Boolean Queries
Ignoring Content of a Descendant Element with Wildcards and
Stemming to 15.2.4 Q4 Window Query with Wildcards and Stemming
Ignoring Content of a Descendant Element. Rewrote the query.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2005-08-25</td>
<td>Changed window syntax</td>
<td>Changed to new window syntax, removing FTRange. Changed the
syntax in 12.2.3 Q3 Ordered Window Query and 15.2.4 Q4 Window Query
with Wildcards and Stemming Ignoring Content of a Descendant
Element.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2006-01-06</td>
<td>Corrected operands</td>
<td>Corrected the operands in XQuery and XPath solutions to 3.2.6.
Q6 Query on Entire Document.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2006-01-06</td>
<td>Added 3 new use cases</td>
<td>Added 8.2.3. Q3 Query Excluding a Stop Word on a Stop Word
List, 6.2.9 Q9 Query Using an XQuery Expression to Determine the
Number of Words Allowed in a Window, and 17.2.6. Query with Weight
Declaration.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2006-01-06</td>
<td>Revised level by level ignore query</td>
<td>Revised 14.2.4. Q4 Distance Query Ignoring Content of
Descendant Elements Level by Level.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2006-02-02</td>
<td>Changed use of curly braces</td>
<td>Changed the use of curly braces in 16.2.8. Q8 Query with XPath
Expression Within Full-Text Expression to reflect Task Force
decision that curly braces surround XQuery expressions when they
are within an FTContainsExpr where an FTSelection may occur (they
are optional for literals).</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2006-11-17</td>
<td>Corrected operator</td>
<td>Corrected operator in Use Case 2.2.4 Q4 Query in Different
Elements from an or to a union because it is operating on
nodes.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2007-02-24</td>
<td>Changed syntax for and, or, not</td>
<td>Changed syntax for the full-text and, or, not operators from
&amp;&amp;, ||, ! to ftand, ftor, ftnot.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2007-02-24</td>
<td>Moved ordered keywords</td>
<td>Moved ordered keywords before distance and window operators so
ordered is processed before distance and window.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2007-09-24</td>
<td>Updated use cases with diacritics match options</td>
<td>Updated use cases with diacritics match options to use the 2
remaining diacritics options: diacritics sensitive and diacritics
insensitive.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2007-09-24</td>
<td>Updated 16.2.9 Q9 Query Using an XQuery Expression to Determine
the Number of Words Allowed in a Window</td>
<td>In 16.2.9 Q9 Query Using an XQuery Expression to Determine the
Number of Words Allowed in a Window removed the FTRange that is no
longer available in a window query.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2007-09-24</td>
<td>Updated sounds-like and spelled-like queries</td>
<td>Updated sounds-like and spelled-like queries to remove
unnecessary "where count($cont)&gt;0" statements.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2007-09-24</td>
<td>Updated return statements</td>
<td>Updated return statements through the document, placing
parentheses around return statements containing commas.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2007-09-24</td>
<td>Updated 16.2.7 Q7 Full-Text Query with Date Comparison and
Element Occurrence Count</td>
<td>In 16.2.7 Q7 Full-Text Query with Date Comparison and Element
Occurrence Count replaced $book with . where $book appeared in
predicates.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2007-09-24</td>
<td>Updated 14.2.4 Q4 Distance Query Ignoring Content of Descendant
Elements Level by Level</td>
<td>In 14.2.4 Q4 Distance Query Ignoring Content of Descendant
Elements Level by Level corrected variable name.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2007-09-24</td>
<td>Updated 16.2.2 Q2 Full-Text Query Returning Count of Descendant
Element Occurrences</td>
<td>In 16.2.2 Q2 Full-Text Query Returning Count of Descendant
Element Occurrences corrected parentheses and brackets in the
return statement.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2007-12-04</td>
<td>Title</td>
<td>Updated title and title references to remove 1.0, 2.0, and the
hyphen.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2007-12-04</td>
<td>Removed Appendix C: Issues.</td>
<td>Removed Appendix C: Issues, transferring the only issue
(testing the use cases for static errors) to Bugzilla.</td>
</tr>
</tbody>
</table>
</div>
</div>
</body>
</html>
